<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Language Tour on</title><link>https://next.pomsky-lang.org/docs/language-tour/</link><description>Recent content in Language Tour on</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><lastBuildDate>Tue, 17 May 2022 13:55:00 +0000</lastBuildDate><atom:link href="https://next.pomsky-lang.org/docs/language-tour/index.xml" rel="self" type="application/rss+xml"/><item><title>Strings</title><link>https://next.pomsky-lang.org/docs/language-tour/strings/</link><pubDate>Tue, 17 May 2022 13:55:00 +0000</pubDate><guid>https://next.pomsky-lang.org/docs/language-tour/strings/</guid><description>First, let&amp;rsquo;s get familiar with the basic building blocks of the language.
Pomsky expressions describe the syntactical structure of a text. There are several kinds of expressions. The most important kind is the string:
'test' This is an expression matching the text test. Note that strings are always wrapped in quotes. This is how we can distinguish strings from other kinds of expressions!
Multiple strings can be concatenated by writing them in succession:</description></item><item><title>Alternations</title><link>https://next.pomsky-lang.org/docs/language-tour/alternations/</link><pubDate>Tue, 17 May 2022 13:55:00 +0000</pubDate><guid>https://next.pomsky-lang.org/docs/language-tour/alternations/</guid><description>What if we want to match multiple strings? Say, we want to match the texts one, two, three, four, and five:
'one' | 'two' | 'three' | 'four' | 'five' It&amp;rsquo;s that easy, just separate all alternatives with a vertical bar. This is called an alternation. The | can be read as &amp;ldquo;or&amp;rdquo;, since the above matches 'one' or 'two' or 'three' or 'four' or 'five'.
Grouping #If we want to concatenate an alternation, we need to wrap it in parentheses:</description></item><item><title>Repetitions</title><link>https://next.pomsky-lang.org/docs/language-tour/repetitions/</link><pubDate>Tue, 17 May 2022 13:55:00 +0000</pubDate><guid>https://next.pomsky-lang.org/docs/language-tour/repetitions/</guid><description>When we want to match an expression multiple times, it would be cumbersome to repeat our expression. Instead, we can specify how often the expression should occur:
('r' | 'w' | 'x' | '-'){9} This matches an r, w, x or - character 9 times. For example, it would match the string rwxr-xr--, or xxrr-xr-w.
What if we want to match strings of different lengths? Repetitions are quite flexible, so we can specify a lower and upper bound for the number of repetitions:</description></item><item><title>Dots</title><link>https://next.pomsky-lang.org/docs/language-tour/dots/</link><pubDate>Fri, 03 Nov 2023 18:00:00 +0000</pubDate><guid>https://next.pomsky-lang.org/docs/language-tour/dots/</guid><description>You can use the dot (.) to match any character, except line breaks. For example:
... # 3 characters Most regex engines have a &amp;ldquo;singleline&amp;rdquo; option that changes the behavior of .. When enabled, . matches everything, even line breaks. You could use this to check if a text fits in an SMS:
.{1,160} # enforces the 160 character limit If you want to match any character, without having to enable the &amp;ldquo;singleline&amp;rdquo; option, Pomsky also offers the variable C, or Codepoint:</description></item><item><title>Character Sets</title><link>https://next.pomsky-lang.org/docs/language-tour/character-sets/</link><pubDate>Tue, 17 May 2022 13:55:00 +0000</pubDate><guid>https://next.pomsky-lang.org/docs/language-tour/character-sets/</guid><description>What if we want to match an arbitrary word? Enumerating every single word is obviously not feasible, so what to do instead? We can enumerate all letters and repeat them:
( | 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z' )+ But this is very verbose and still only matches lowercase letters.</description></item><item><title>Shorthands</title><link>https://next.pomsky-lang.org/docs/language-tour/shorthands/</link><pubDate>Tue, 17 May 2022 13:55:00 +0000</pubDate><guid>https://next.pomsky-lang.org/docs/language-tour/shorthands/</guid><description>There are abbreviations, called shorthands, for often needed character sets:
[digit] or [d] matches a decimal number. It is similar to ['0'-'9'], except that it is Unicode aware.
[word] or [w] matches a word character, i.e. a letter, digit or underscore. It&amp;rsquo;s similar to ['0'-'9' 'a'-'z' 'A'-'Z' '_'], except that it is Unicode aware. It matches all codepoints in the Alphabetic, Mark, Decimal_Number, Connector_Punctuation, and Join_Control Unicode categories.
[space] or [s] matches whitespace.</description></item><item><title>Anchors</title><link>https://next.pomsky-lang.org/docs/language-tour/anchors/</link><pubDate>Fri, 03 Nov 2023 18:00:00 +0000</pubDate><guid>https://next.pomsky-lang.org/docs/language-tour/anchors/</guid><description>Anchors match the start or end of the text. ^ matches the start, and $ matches the end. Anchors are important because regex engines typically match substrings of the text, but sometimes you want the entire text to match.
For example: Let&amp;rsquo;s say a user entered a phone number, and you want to check if it is valid. You use the following expression:
'+'? [ascii_digit '-()/ ']+ But this also finds a match in texts that aren&amp;rsquo;t valid phone numbers:</description></item><item><title>Word Boundaries</title><link>https://next.pomsky-lang.org/docs/language-tour/word-boundaries/</link><pubDate>Tue, 17 May 2022 13:55:00 +0000</pubDate><guid>https://next.pomsky-lang.org/docs/language-tour/word-boundaries/</guid><description>Word boundaries match a position where a word starts or ends. Like anchors, they do not consume any characters &amp;ndash; they have a length of 0. Expressions like this are called assertions.
There are three kinds of word boundaries:
&lt; to match at the start of a word > to match at the end of a word % to match either at the start or at the end of a word.</description></item><item><title>Modifiers</title><link>https://next.pomsky-lang.org/docs/language-tour/modifiers/</link><pubDate>Fri, 03 Nov 2023 18:00:00 +0000</pubDate><guid>https://next.pomsky-lang.org/docs/language-tour/modifiers/</guid><description>Modifiers allow you to change the behavior of a Pomsky expression. Modifiers are statements; they can appear either at the top of the file, or inside a group:
disable unicode; [word]+ (enable unicode; '.' [word]+) Modifiers must appear before the expression they modify. They consist of two parts: The enable or disable keyword, and a mode, followed by a ;.
There are currently two modes that can be enabled or disabled:</description></item><item><title>Capturing Groups</title><link>https://next.pomsky-lang.org/docs/language-tour/capturing-groups/</link><pubDate>Tue, 17 May 2022 13:55:00 +0000</pubDate><guid>https://next.pomsky-lang.org/docs/language-tour/capturing-groups/</guid><description>As we have seen before, parentheses can be used to group expressions together. Capturing groups are a special kind of group that capture their matched text. This allows extracting information from matches later.
Here is an example where a Pomsky expression is used to match a semantic version number:
# a semver version number, e.g. '1.3.17' :([digit]+) '.' :([digit]+) '.' :([digit]+) The : in front of the groups turns them into capturing groups.</description></item></channel></rss>