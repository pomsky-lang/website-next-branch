<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Constructs on</title><link>/docs/reference/constructs/</link><description>Recent content in Constructs on</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><lastBuildDate>Tue, 17 May 2022 13:55:00 +0000</lastBuildDate><atom:link href="/docs/reference/constructs/index.xml" rel="self" type="application/rss+xml"/><item><title>Alternation</title><link>/docs/reference/constructs/alternation/</link><pubDate>Mon, 23 Oct 2023 09:31:00 +0000</pubDate><guid>/docs/reference/constructs/alternation/</guid><description>An alternation matches one of several alternatives.
Syntax #let Alternation = ('|'? Alternatives)?; let Alternatives = Alternative ('|' Alternative)*; let Alternative = FixExpression+; See FixExpression.
Note that an alternation may have a leading pipe. Also note that an alternative may not be empty, i.e. | | is not allowed. Use an empty string instead, e.g. 'foo' | '' | 'bar'.
Example #| 'hello' | 'pomsky'+ Support #Alternation is supported in all flavors.</description></item><item><title>Boundaries</title><link>/docs/reference/constructs/boundary/</link><pubDate>Mon, 23 Oct 2023 09:31:00 +0000</pubDate><guid>/docs/reference/constructs/boundary/</guid><description>Boundaries (word boundaries and anchors) are assertions that match if the current position has a certain property.
Syntax #let Boundary = | '^' | '$' | '%' | '&amp;lt;' | '&amp;gt;'; Example #^ $ # match empty string % 'foo' % # match 'foo' surrounded by word boundaries !% 'foo' !% # match 'foo' not surrounded by word boundaries &amp;lt; 'foo' &amp;gt; # match 'foo' as a whole word Support #Anchors (^ and $) are supported in all flavors.</description></item><item><title>Character Set</title><link>/docs/reference/constructs/charset/</link><pubDate>Mon, 23 Oct 2023 09:31:00 +0000</pubDate><guid>/docs/reference/constructs/charset/</guid><description>A character set allows matching one of several code points.
Syntax #let CharacterSet = '[' CharacterSetInner+ ']'; let CharacterSetInner = | Range | String | CodePoint | NonPrintable | Shorthand | UnicodeProperty | AsciiShorthand; let Range = SingleChar '-' SingleChar; let SingleChar = | StringOneChar | CodePoint | NonPrintable; # deprecated! let NonPrintable = | 'n' | 'r' | 't' | 'a' | 'e' | 'f'; let Shorthand = '!'? ShorthandIdent; let ShorthandIdent = | 'w' | 'word' | 'd' | 'digit' | 's' | 'space' | 'h' | 'horiz_space' | 'v' | 'vert_space' let AsciiShorthand = | 'ascii' | 'ascii_alpha' | 'ascii_alnum' | 'ascii_blank' | 'ascii_cntrl' | 'ascii_digit' | 'ascii_graph' | 'ascii_lower' | 'ascii_print' | 'ascii_punct' | 'ascii_space' | 'ascii_upper' | 'ascii_word' | 'ascii_xdigit'; let UnicodeProperty = '!</description></item><item><title>Dot</title><link>/docs/reference/constructs/dot/</link><pubDate>Mon, 23 Oct 2023 09:31:00 +0000</pubDate><guid>/docs/reference/constructs/dot/</guid><description>The dot matches an arbitrary code point except a line break. In multiline mode, the dot also matches line breaks.
Syntax #let Dot = '.'; Example #.{4,12} Support #The dot is supported in all flavors.
In .NET, the dot matches a UTF-16 code unit rather than a full code point, so a character outside the Basic Multilingual Plane matches two dots (..).
Support for the dot is gated by the dot feature.</description></item><item><title>Groups</title><link>/docs/reference/constructs/group/</link><pubDate>Mon, 23 Oct 2023 09:31:00 +0000</pubDate><guid>/docs/reference/constructs/group/</guid><description>Multiple expressions can be grouped together by wrapping them in parentheses. Capturing groups can be used to extract information from a match.
Syntax #let Group = GroupKind? '(' Expression ')'; let GroupKind = | ':' Name? | 'atomic'; See Expression.
A group name must be ASCII-only and may not contain underscores. Furthermore, a group name must be no longer than 32 characters. For example:
:underscores_are_invalid() :äöéŧûøIsInvalid() :thisGroupNameIsTooLongUnfortunately() :thisIsAllowed() These restrictions exist because of Java.</description></item><item><title>Inline Regex</title><link>/docs/reference/constructs/inline-regex/</link><pubDate>Mon, 23 Oct 2023 09:31:00 +0000</pubDate><guid>/docs/reference/constructs/inline-regex/</guid><description>Inline regexes allow you to embed regular expressions in Pomsky.
Syntax #let InlineRegex = 'regex' String; Example #regex '(?2)' # subroutine regex '[\w--[\p{Latin}]]' # character set subtraction Support #Inline regexes are supported in all flavors.
Support for inline regexes is gated by the regexes feature. Specify features with the --allowed-features option.
Behavior #Inline regexes can do anything the targeted regex engine supports. However, inline regexes may not be as portable, because different regex engines use slightly different syntax for some features.</description></item><item><title>Lookaround</title><link>/docs/reference/constructs/lookaround/</link><pubDate>Mon, 23 Oct 2023 09:31:00 +0000</pubDate><guid>/docs/reference/constructs/lookaround/</guid><description>Lookarounds assert that a certain expression matches before or after the current position. As an assertion, a lookaround does not contain any text; it matches between two code points.
Syntax #let Lookaround = LookaroundPrefix Expression; let LookaroundPrefix = | '&amp;lt;&amp;lt;' | '&amp;gt;&amp;gt;'; See Expression.
A lookaround must be wrapped in parentheses if it is followed by another expression:
(&amp;gt;&amp;gt; [word]) [Greek] Note that a lookaround contains an expression, so it introduces a new scope and can include statements.</description></item><item><title>Modifier</title><link>/docs/reference/constructs/modifier/</link><pubDate>Mon, 23 Oct 2023 09:31:00 +0000</pubDate><guid>/docs/reference/constructs/modifier/</guid><description>Modifiers change how the following expression should be treated.
Syntax #let Modifier = ModifierKeyword BooleanSetting ';'; let ModifierKeyword = | 'enable' | 'disable'; let BooleanSetting = | 'lazy' | 'unicode'; Example #enable lazy; disable unicode; [w]* ( disable lazy; .+ ) Support #Modifiers are supported in all flavors.
Support for each mode is gated by the lazy-mode and ascii-mode features. Specify features with the --allowed-features option.
Behavior #Modes can be enabled and disabled in any scope.</description></item><item><title>Negation</title><link>/docs/reference/constructs/negation/</link><pubDate>Mon, 23 Oct 2023 09:31:00 +0000</pubDate><guid>/docs/reference/constructs/negation/</guid><description>Anything that can be compiled to a lookaround, word boundary, or a character set can be negated.
Syntax #let Negation = '!' FixExpression; See FixExpression.
Example #let no_boundary = !%; !no_boundary (!&amp;gt;&amp;gt; !'a') Support #Negation is supported in all flavors.
Behavior #The following kinds of expression can be negated:
Word boundary % Lookarounds &amp;lt;&amp;lt;, &amp;gt;&amp;gt; Character set [...] Strings with exactly one code point Negations Negation happens late in the compilation process, after variable and range expansion, and some optimizations.</description></item><item><title>Number ranges</title><link>/docs/reference/constructs/number-range/</link><pubDate>Mon, 23 Oct 2023 09:31:00 +0000</pubDate><guid>/docs/reference/constructs/number-range/</guid><description>Number ranges are used to match multi-digit numbers. If you only need to match a single digit, you can use a character set instead.
Syntax #let NumberRange = 'range' String '-' String Base?; let Base = 'base' Number; Note that the strings must contain digits or ASCII letters in the supported range. For example, in base 16, the characters 0123456789abcdefABCDEF are allowed. The base must be between 2 and 36.</description></item></channel></rss>