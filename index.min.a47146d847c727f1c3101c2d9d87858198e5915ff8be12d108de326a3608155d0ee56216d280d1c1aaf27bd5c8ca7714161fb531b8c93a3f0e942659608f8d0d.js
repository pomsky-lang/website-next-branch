var suggestions=document.getElementById("suggestions"),search=document.getElementById("search");search!==null&&document.addEventListener("keydown",inputFocus);function inputFocus(e){e.ctrlKey&&e.key==="/"&&(e.preventDefault(),search.focus()),e.key==="Escape"&&(search.blur(),suggestions.classList.add("d-none"))}document.addEventListener("click",function(e){var t=suggestions.contains(e.target);t||suggestions.classList.add("d-none")}),document.addEventListener("keydown",suggestionFocus);function suggestionFocus(e){const s=suggestions.classList.contains("d-none");if(s)return;const t=[...suggestions.querySelectorAll("a")];if(t.length===0)return;const n=t.indexOf(document.activeElement);if(e.key==="ArrowUp"){e.preventDefault();const s=n>0?n-1:0;t[s].focus()}else if(e.key==="ArrowDown"){e.preventDefault();const s=n+1<t.length?n+1:n;t[s].focus()}}(function(){var e=new FlexSearch.Document({tokenize:"forward",cache:100,document:{id:"id",store:["href","title","description"],index:["title","description","content"]}});e.add({id:0,href:"/docs/get-started/introduction/",title:"Introduction",description:"Summary of what pomsky is and what it looks like",content:"Pomsky is a language that compiles to regular expressions. It is currently in an alpha stage and will likely change in the next few releases.\nUsage #Pomsky can be used with a CLI, a JavaScript plugin, or a Rust macro. See installation instructions.\nYou should also enable Unicode support in your regex engine if it isn\u0026rsquo;t supported by default. See instructions.\nSummary #\r👉 Here you can see all the features at a glance. Don't worry, they will be explained in detail in the language tour. On the left are pomsky expressions, on the right are the equivalent regexes:\n# String 'hello world' # hello world # Greedy repetition 'hello'{1,5} # (?:hello){1,5} 'hello'* # (?:hello)* 'hello'+ # (?:hello)+ # Lazy repetition 'hello'{1,5} lazy # (?:hello){1,5}? 'hello'* lazy # (?:hello)*? 'hello'+ lazy # (?:hello)+? # Alternation 'hello' | 'world' # hello|world # Character classes ['aeiou'] # [aeiou] ['p'-'s'] # [p-s] # Named character classes [word] [space] [n] # \\w\\s\\n # Combined [w 'a' 't'-'z' U+15] # [\\wat-z\\x15] # Negated character classes !['a' 't'-'z'] # [^at-z] # Unicode [Greek] U+30F Grapheme # \\p{Greek}\\u030F\\X # Boundaries ^ $ # ^$ % 'hello' !% # \\bhello\\B # Non-capturing groups 'terri' ('fic' | 'ble') # terri(?:fic|ble) # Capturing groups :('test') # (test) :name('test') # (?P\u0026lt;name\u0026gt;test) # Lookahead/lookbehind \u0026gt;\u0026gt; 'foo' | 'bar' # (?=foo|bar) \u0026lt;\u0026lt; 'foo' | 'bar' # (?\u0026lt;=foo|bar) !\u0026gt;\u0026gt; 'foo' | 'bar' # (?!foo|bar) !\u0026lt;\u0026lt; 'foo' | 'bar' # (?\u0026lt;!foo|bar) # Backreferences :('test') ::1 # (test)\\1 :name('test') ::name # (?P\u0026lt;name\u0026gt;test)\\1 # Ranges range '0'-'999' # 0|[1-9][0-9]{0,2} range '0'-'255' # 0|1[0-9]{0,2}|2(?:[0-4][0-9]?|5[0-5]?|[6-9])?|[3-9][0-9]? Variables #let operator = '+' | '-' | '*' | '/'; let number = '-'? [digit]+; number (operator number)* "}),e.add({id:1,href:"/docs/get-started/quick-start/",title:"Quick Start",description:"Summary of how to start using pomsky.",content:`Playground #Using the playground is the easiest and most convenient way to get started using pomsky. It supports syntax highlighting and shows errors directly in your code.
CLI #The CLI allows you to compile pomsky expressions to regexes in the command line.
Use pre-built binaries #Binaries are available for Windows, Linux and macOS. Download them from the releases page.
Use AUR package #On Arch Linux, you can use the AUR package with
yay -S pomsky-bin Install from source #This requires that a recent Rust toolchain is installed. Instructions for how to install Rust can be found here.
Install the CLI with
cargo install pomsky-bin Get help #To find out how to use the CLI, run
pomsky --help Node module #Pomsky can be used with the @pomsky-lang/compiler-web npm module. Install with
$ npm i -s @pomsky-lang/compiler-web # yarn add @pomsky-lang/compiler-web Then import and use it like this:
import init, { compile } from '@pomsky-lang/compiler-web' init().then(() =\u0026gt; { const input = \`^ ('test' '!'+)? $\` const { output } = compile(input, 'js') console.log(output) }) It currently works in browsers, but not in Node. If you use vite for bundling, you need to disable optimizations for @pomsky-lang/compiler-web in development mode:
// vite.config.js import { defineConfig } from 'vite' export default defineConfig((config) =\u0026gt; ({ optimizeDeps: { exclude: config.mode === 'production' ? [] : ['@pomsky-lang/compiler-web'], }, })) The compile function throws an exception if compilation fails.
Rust macro #If you want to write a pomsky expression directly in your Rust source code, the pomsky-macro got you covered. Run this command:
cargo add pomsky-macro Then you can import and use it with
use pomsky_macro::pomsky; const MY_REGEX: \u0026amp;str = pomsky!([\u0026quot;great!\u0026quot;] | \u0026quot;great!\u0026quot;); Documentation can be found here.
`}),e.add({id:2,href:"/docs/get-started/enable-unicode/",title:"Enable Unicode Support",description:"Configure the RegExp engine to support Unicode.",content:`Pomsky has good Unicode support, but you might still have to enable Unicode support in your regex engine. This document explains how to do that for various regex engines.
If some information here is missing, outdated or needs clarification, I would greatly appreciate your help! You can edit this file on GitHub.
Rust #The Rust regex crate is Unicode-aware by default. There\u0026rsquo;s nothing you need to do.
JavaScript #In JavaScript, set the u flag, for example /[\\w\\s]/u. This makes it possible to use Unicode properties (\\p{...}) and code points outside of the BMP (\\u{...}).
Since \\w and \\d are not Unicode aware even when the u flag is enabled, pomsky polyfills them. However, word boundaries aren\u0026rsquo;t Unicode aware, and there\u0026rsquo;s no straightforward solution for this. To make word boundaries behave correctly, you can use the following insteand of % and !%:
let wstart = (!\u0026lt;\u0026lt; [w]) (\u0026gt;\u0026gt; [w]); # start of a word let wend = (\u0026lt;\u0026lt; [w]) (!\u0026gt;\u0026gt; [w]); # end of a word let wbound = wstart | wend; # word boundary (%, but Unicode aware) let wmid = (\u0026lt;\u0026lt; [w]) (\u0026gt;\u0026gt; [w]); # middle of a word let wout = (!\u0026lt;\u0026lt; [w]) (!\u0026gt;\u0026gt; [w]); # outside of a word let nwbound = wmid | wout # not a word boundary (!%, but Unicode aware) This is not used by default because it makes the generated output much bigger.
PHP #PHP is Unicode-aware if the u flag is set, and this also applies to \\w, \\d, \\s and \\b. For example, '/\\w+/u' matches a word in any script.
Java, Kotlin, Scala #Add (?U) in front of the regex to make it Unicode-aware. For example, \u0026quot;(?U)\\\\w+\u0026quot; matches a word in any script.
Ruby #In Ruby, add (?u) in front of the regex to make it Unicode-aware. For example, /(?u)\\w+/ matches a word in any script.
Python #In the Python re module, \\w, \\d, \\s and \\b are Unicode-aware since Python 3.
If you\u0026rsquo;re still using Python 2, you can use the regex module from November 2021; releases newer than that don\u0026rsquo;t support Python 2.
Elixir #Regexes in Elixir are Unicode-aware if the u flag is added. For example, ~r/\\w+/u matches a word in any script.
Erlang #You need to set the unicode and ucp options to make regexes Unicode aware. For example, re:compile(\u0026quot;\\\\w+\u0026quot;, [unicode, ucp]) matches a word in any script.
PCRE #PCRE supports Unicode, but to make \\w, \\d, \\s and \\b Unicode-aware, you need to enable both PCRE_UTF8 and PCRE_UCP.
`}),e.add({id:3,href:"/docs/language-tour/basics/",title:"Basics",description:"Comments, strings, alternation",content:`First, let\u0026rsquo;s get familiar with the basic building blocks of the language.
Pomsky expressions describe the syntactical structure of a text. There are several kinds of expressions, which will be explained now.
In Pomsky, whitespace is insignificant, except between quotes. This means that we can add spaces and line breaks to make the code look clearer. We can also add comments to explain what the expressions are doing. They start with a # and span until the end of the line:
# this is a comment # comments are ignored by pomsky! Strings #In Pomsky, characters that should be matched as-is are always wrapped in quotes. We can use double quotes ("") or single quotes (''). We call text wrapped in quotes a string. It matches the exact content of the string:
\u0026quot;test\u0026quot; In double quoted strings ("..."), double quotes can be escaped by prepending a backslash. Strings in single quotes are \u0026ldquo;raw strings\u0026rdquo; and do not support backslash escapes:
\u0026quot;\\\u0026quot;C:\\\\windows\\\u0026quot;\u0026quot; # is equivalent to '\u0026quot;C:\\windows\u0026quot;' Concatenate expressions #Pomsky consists of expressions. For example, a string is an expression. If we write several expressions in a row, they are matched one after the other:
'hello' 'world' '!' # is equivalent to 'helloworld!' Alternatives #What if we want to match one of several strings? In a regex, we can enumerate multiple alternatives, divided by a |:
one|two|three|four|five The same works in Pomsky:
'one' | 'two' | 'three' | 'four' | 'five' This type of expression is called an alternation. Pomsky also allows a leading |, which looks a bit nicer if we put each alternative on its own line:
| 'one' | 'two' | 'three' | 'four' | 'five' `}),e.add({id:4,href:"/docs/language-tour/groups/",title:"Groups",description:"Learn about capturing and non-capturing and named groups",content:`Multiple expressions can be grouped together by wrapping them in (). This is useful when we have multiple alternatives that all start or end with the same thing:
'tang' ('ible' | 'ent' | 'o') This matches the words tangible, tangent and tango.
Capturing groups #Groups can also be used to capture their content, for example to replace it with something else. In a regex, every group is a capturing group by default. This is not the case in Pomsky: Capturing groups must be prefixed with :.
:('foo') Capturing groups are consecutively numbered, to be able to refer to them later:
:('Max' | 'Laura') (' is ' | ' was ') :('asleep' | 'awake') The first group, containing the name, has index 1, the third group with the adverb has the index 2. The second group is skipped because it isn\u0026rsquo;t capturing (it isn\u0026rsquo;t prefixed with :).
Named capturing groups #Because groups are non-capturing by default, you can add parentheses freely without accidentally changing the capturing group indices. However, it\u0026rsquo;s usually better to use named capturing groups, so you don\u0026rsquo;t need to count groups and instead refer to each group by a name:
:name('Max' | 'Laura') (' is ' | ' was ') :adverb('asleep' | 'awake') Now, the capturing groups are named name and adverb.
Atomic groups #If we put the atomic keyword in front of a group, the RegExp engine can\u0026rsquo;t backtrack into the group. This can improve matching performance and prevent \u0026ldquo;catastrophic backtracking\u0026rdquo;:
% atomic('if' | 'else' | 'while' | 'for') % You can find out more about backtracking here.
Note that atomic groups are only supported in the Java, PCRE, Ruby and .NET flavors.
`}),e.add({id:5,href:"/docs/language-tour/repetitions/",title:"Repetitions",description:"How to repeat an expression, greedily or lazily",content:`When we want to match an expression multiple times, it would be cumbersome to repeat our expression. Instead, we can specify how often the expression should occur:
('r' | 'w' | 'x' | '-'){9} This matches an r, w, x or - character 9 times. For example, it would match the string rwxr-xr--, or xxrr-xr-w.
What if we want to match strings of different lengths? Repetitions are quite flexible, so we can specify a lower and upper bound for the number of repetitions:
('r' | 'w' | 'x' | '-'){3,9} Greedy and lazy matching #The above matches at least 3 times and at most 9 times. By default, repetition is greedy. This means that Pomsky always tries to match an expression as many times as possible. For example, the expression above matches the string rwxr-xr-- entirely. Even though it could stop after the third repetition (the lower bound), it continues to try and match more, until the upper bound is reached.
In situations where this is not desired, you can opt into non-greedy matching with the lazy keyword, for example:
('r' | 'w' | 'x' | '-'){3,9} lazy '--' When given the string rwxr--r--, Pomsky will first repeat the group 3 times (the lower bound). Since there aren\u0026rsquo;t two dashes after 3 characters, it is forced to repeat a fourth time. rwxr is followed by two dashes, so Pomsky returns the match rwxr-- and stops. The other possible match, which is the entire string, isn\u0026rsquo;t found, because the repetition is \u0026ldquo;too lazy\u0026rdquo;.
Variants of repetition #If we want to match an expression arbitrarily often, without an upper bound, we can just omit it:
'test'{3,} There are three kinds of repetition that are very common: {0,} (zero or more), {1,} (one or more) and {0,1} (zero or one). These have dedicated symbols, *, + and ?:
'test'* # match zero times or more 'test'+ # match one time or more 'test'? # match zero or one time You can also add the lazy keyword to them to opt into lazy matching.
Enable lazy matching globally #If you enable the lazy mode, lazy repetition becomes the default, so it\u0026rsquo;s necessary to opt into greedy repetition with the greedy keyword:
enable lazy; 'test'+ # this is lazy 'test'+ greedy Lazy matching can be enabled or disabled in arbitrarily nested groups:
(enable lazy; 'test'+ # this is lazy (disable lazy; 'test'+ # this is greedy ) 'test'+ # this is lazy ) `}),e.add({id:6,href:"/docs/language-tour/character-classes/",title:"Character Classes",description:"Matching a codepoint with certain properties",content:`What if we want to match an arbitrary word? Enumerating every single word is obviously not feasible, so what to do instead? We can simply enumerate the characters and repeat them:
( | 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z' )+ But this is very verbose and still only matches lowercase letters. We programmers tend to be lazy, so there must be a more convenient solution!
Character ranges #This expression matches words that can contain uppercase and lowercase letters:
['a'-'z' 'A'-'Z']+ The square brackets indicate that this is a character class. A character class always matches exactly 1 character (more precisely, a Unicode codepoint). This character class contains two ranges, one for lowercase letters and one for uppercase letters. Together, this matches any character that is either a lowercase or uppercase letter.
It\u0026rsquo;s also possible to add single characters, for example:
['$' '_' 'a'-'z' 'A'-'Z'] When we have several characters in a character class that aren\u0026rsquo;t part of a range, we can simply put them into the same quotes:
['$_' 'a'-'z' 'A'-'Z'] This is equivalent to ('$' | '_' | ['a'-'z' 'A'-'Z']), but it\u0026rsquo;s shorter and may be more efficient.
Character ranges and Unicode #👉 You can skip this section if you are already familiar with Unicode. What is a range, exactly? Let\u0026rsquo;s see with an example:
['0'-'z'] This doesn\u0026rsquo;t seem to make sense, but does work. If you try it out, you\u0026rsquo;ll notice that it matches numbers, lowercase and uppercase letters. However, it also matches a few other characters, e.g. the question mark ?.
The reason is that Pomsky uses Unicode, a standard that assigns every character a numeric value. When we write '0'-'z', Pomsky assumes that we want to match any character whose numeric value is somewhere between the value of '0' and the value of 'z'. This works well for letters (e.g. 'a'-'Z') and numbers ('0'-'9'), because these have consecutive values in Unicode. However, there are some special characters between digits, uppercase letters and lowercase letters:
Character Unicode value '0' 48 '1' 49 '2' 50 \u0026hellip; '9' 57 ':' 58 ';' 59 '\u0026lt;' 60 '=' 61 '\u0026gt;' 62 '?' 63 '@' 64 'A' 65 'B' 66 \u0026hellip; 'Z' 90 '[' 91 '\\' 92 ']' 93 '^' 94 '_' 95 '\`' 96 'a' 97 \u0026hellip; 'z' 122 Why, you might ask? This is for historical reasons.
Unicode properties #The reason why Unicode was invented is that most people in the world don\u0026rsquo;t speak English, and many of them use languages with different alphabets. To support them, Unicode includes 144,697 codepoints covering 159 different scripts. Since we have a standard that makes it really easy to support different languages, there\u0026rsquo;s no excuse for not using it.
The character class ['a'-'z' 'A'-'Z'] only recognizes Latin characters. What should we do instead? We should use a general category. In this case, Letter seems like a good candidate. Pomsky makes it easy to use Unicode categories:
[Letter] That\u0026rsquo;s it. This matches any letter from all 159 scripts! It\u0026rsquo;s also possible to match any codepoint in a certain script:
[Cyrillic Hebrew] This matches a Cyrillic or Hebrew codepoint.
Most regex engines can also match Unicode properties other than categories and scripts. Useful properties include
Alpha (letters and marks that can appear in a word) Upper, Lower (uppercase or lowercase letters) Emoji Math (mathematical symbols) You can see the full list of Unicode properties here.
What\u0026rsquo;s a codepoint? #A Unicode codepoint usually, but not always, represents a character. Exceptions are composite characters like ć (which may consist of a ´ and a c when it isn\u0026rsquo;t normalized). Composite characters are common in many scripts, including Japanese, Indian and Arabic scripts. Also, an emoji can consist of multiple codepoints, e.g. when it has a gender or skin tone modifier.
Most regex engines look at one codepoint at a time. This means that [Letter] matches exactly one codepoint. The exception is .NET, which does not properly support Unicode, and character classes in .NET can only match codepoints from the Basic Multilingual Plane.
Negation #Character classes are negated by putting a ! in front of it. For example, !['a'-'f'] matches anything except a letter in the range from a to f.
It\u0026rsquo;s also possible to negate Unicode properties individually. For example, [Latin !Alpha] matches a codepoint that is either in the Latin script, or is not alphabetic.
Dot #You can use the dot (.) to match any codepoint, except line breaks. For example:
... # 3 codepoints (except line breaks) Most regex engines have a \u0026ldquo;singleline\u0026rdquo; option that changes the behavior of .. When enabled, . matches everything, even line breaks. Usually, the dot does not match \\n (line feed) and possibly more line break characters depending on the regex flavor.
If you want to match any character, without having to enable the \u0026ldquo;singleline\u0026rdquo; option, Pomsky also offers the variable C (or Codepoint):
C C C # 3 codepoints Note that the number of codepoints is not always the number of visible characters. Also note that .NET does not properly support Unicode, and matches UTF-16 code units instead of codepoints. This means that when encountering a codepoint outside of the BMP, .NET matches each UTF-16 surrogate individually, so one . or C may match only half a codepoint in .NET.
Repeating the dot #Be careful when repeating C or .. My personal recommendation is to never repeat them. Let\u0026rsquo;s see why:
'{' .* '}' This matches any content surrounded by curly braces. Why is this bad? Because .* will greedily consume anything, even curly braces, so looking for matches in the string {ab} de {fg} will return the whole string, but we probably expected to get the two matches {ab} and {fg}.
We can fix this by making the repetition lazy:
'{' .* lazy '}' However, if the expression is followed by anything else, the dot may still consume curly braces. For example:
'{' .* lazy '};' This expression will match the text {foo}}}};, which may not be desired. So it is usually better to restrict which characters can be repeated:
'{' !['{}']* '};' Now the curly braces can contain anything except { and }, so we know that it will stop repeating when a brace is encountered, and fail if there\u0026rsquo;s no };.
`}),e.add({id:7,href:"/docs/language-tour/shorthands/",title:"Shorthands",description:"Character class shorthands",content:`There are a few shorthand character classes: word, digit, space, horiz_space and vert_space. They can be abbreviated with their first letter: w, d, s, h and v. Like Unicode properties, they must appear in square brackets.
word matches a word character, i.e. a letter, digit or underscore. It\u0026rsquo;s equivalent to [Alphabetic Mark Decimal_Number Connector_Punctuation Join_Control]. digit matches a digit. It\u0026rsquo;s equivalent to Decimal_Number. space matches whitespace. It\u0026rsquo;s equivalent to White_Space. horiz_space matches horizontal whitespace (tabs and spaces). It\u0026rsquo;s equivalent to [U+09 Space_Separator]. vert_space matches vertical whitespace. It\u0026rsquo;s equivalent to [U+0A-U+0D U+85 U+2028 U+2029]. Note that word, digit and space only match ASCII characters, if the regex engine isn\u0026rsquo;t configured to be Unicode-aware. How to enable Unicode support is described here.
If you want to match any code point, you can use Codepoint, or C for short. This does not require brackets, because it is a built-in variable. For example, this matches a double-quoted string:
'\u0026quot;' Codepoint* lazy '\u0026quot;' What if I don\u0026rsquo;t need Unicode? #You don\u0026rsquo;t have to use Unicode-aware character classes such as [word] if you know that the input is only ASCII. Unicode-aware matching can be considerably slower. For example, the [word] character class includes more than 100,000 code points, so matching a [ascii_word], which includes only 63 code points, is faster.
Pomsky supports a number of ASCII-only shorthands:
Character class Equivalent [ascii] [U+00-U+7F] [ascii_alpha] ['a'-'z' 'A'-'Z'] [ascii_alnum] ['0'-'9' 'a'-'z' 'A'-'Z'] [ascii_blank] [' ' U+09], [ascii_cntrl] [U+00-U+1F U+7F] [ascii_digit] ['0'-'9'] [ascii_graph] ['!'-'~'] [ascii_lower] ['a'-'z'] [ascii_print] [' '-'~'] [ascii_punct] ['!'-'/' ':'-'@' '['-'\`' '{'-'~'] [ascii_space] [' ' U+09-U+0D] [ascii_upper] ['A'-'Z'] [ascii_word] ['0'-'9' 'a'-'z' 'A'-'Z' '_'] [ascii_xdigit] ['0'-'9' 'a'-'f' 'A'-'F'] Using them can improve performance, but be careful when you use them. If you aren\u0026rsquo;t sure if the input will ever contain non-ASCII characters, it\u0026rsquo;s better to err on the side of correctness, and use Unicode-aware character classes.
Non-printable characters #Characters that can\u0026rsquo;t be printed should be replaced with their hexadecimal Unicode code point. For example, you may write U+FEFF to match the Zero Width No-Break Space.
There are also 6 non-printable characters with a name:
[n] is equivalent to [U+0A], the \\n line feed. [r] is equivalent to [U+0D], the \\r carriage return. [f] is equivalent to [U+0C], the \\f form feed. [a] is equivalent to [U+07], the \u0026ldquo;alert\u0026rdquo; or \u0026ldquo;bell\u0026rdquo; control character. [e] is equivalent to [U+0B], the \u0026ldquo;escape\u0026rdquo; control character. Other characters have to be written in their hexadecimal form. Note that you don\u0026rsquo;t need to write leading zeroes, i.e. U+0 is just as ok as U+0000. However, it is conventional to write ASCII characters with two digits and non-ASCII characters with 4, 5 or 6 digits depending on their length.
`}),e.add({id:8,href:"/docs/language-tour/boundaries/",title:"Boundaries",description:"Matching the start/end of a word or string",content:`Boundaries match a position in a string without consuming any code points. There are 4 boundaries:
% matches a word boundary. It matches successfully if it is preceded, but not succeeded by a word character, or vice versa. For example, Codepoint % Codepoint matches A; and ;A, but not AA or ;;.
!% matches a position that is not a word boundary. For example, Codepoint !% Codepoint matches aa and ::, but not a: or :a.
^ (or Start) matches the start of the string.
$ (or End) matches the end of the string.
A word character is anything that matches [word]. If the regex engine is Unicode-aware, this is [Alphabetic Mark Decimal_Number Connector_Punctuation]. For some regex engines, Unicode-aware matching has to be enabled first (see here).
In JavaScript, % and !% is never Unicode-aware, even when the u flag is set. That\u0026rsquo;s why Unicode must be disabled to use them:
disable unicode; % 'Pomsky' % Note that a disable statement can be nested within a group:
(disable unicode; %) 'Pomsky' (disable unicode; %) This can be useful when you want to only disable Unicode for part of an expression.
`}),e.add({id:9,href:"/docs/language-tour/lookaround/",title:"Lookaround",description:"Matching forwards or backwards without consuming characters",content:`Lookarounds provide the ability to see if the characters before or after the current position match a certain expression. There are four variants:
\u003e\u003e, a positive lookahead. For example, (\u003e\u003e [w]) matches if the position is followed by a word character. That character isn\u0026rsquo;t included in the match.
\u003c\u003c, a positive lookbehind. For example, (\u003c\u003c [w]) matches if the position is directly after a word character.
!\u003e\u003e, a negative lookahead. For example (!\u003e\u003e [w]) matches if the position is not followed by a word character. Note that this also matches at the end of the string, so it\u0026rsquo;s not the same as (\u003e\u003e ![w]), which would require that the position is followed by at least one character.
!\u003c\u003c, a negative lookbehind. For example (!\u003c\u003c [w]) matches if the position is not directly after a word character. This also matches at the start of the string, so it\u0026rsquo;s not the same as (\u003c\u003c ![w]).
Note that lookbehind isn\u0026rsquo;t supported everywhere, for example in Safari.
Lookaround makes it possible to match a string in multiple ways. For example, (!\u003e\u003e ('_' | 'for' | 'while' | 'if') %) [w]+ % matches a string consisting of word characters, but not one of the keywords _, for, while and if. Be careful when using this technique, because the lookahead might not match the same length as the expression after it. Here, we ensured that both match until the end of the word with %.
`}),e.add({id:10,href:"/docs/language-tour/ranges/",title:"Ranges",description:"Matching a number in a certain range",content:`Writing a regex matching a number in a certain range can be quite difficult. For example, the following regex matches a number between 0 and 255:
(?:2(?:5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9]) This has many downsides:
It\u0026rsquo;s not readable It\u0026rsquo;s difficult to come up with It\u0026rsquo;s easy to make a mistake somewhere It\u0026rsquo;s inefficient; a typical regex engine needs to backtrack in several places Pomsky solves these problems with its range syntax:
range '0'-'255' Pomsky creates a DFA (deterministic finite automaton) from this, so the generated regex is optimal in terms of matching performance. Since the algorithm for creating this regex is extensively tested, you can also rely on it\u0026rsquo;s correctness. Here\u0026rsquo;s the regex generated from range '0'-'255':
0|1[0-9]{0,2}|2(?:[0-4][0-9]?|5[0-5]?|[6-9])?|[3-9][0-9]? Different bases #Pomsky can generate ranges in various bases. For example, to match hexadecimal numbers in a certain range, you might write:
range '10F'-'FFFF' base 16 This generates this regex:
1(?:0(?:[0-9a-eA-E][0-9a-fA-F]|[fF][0-9a-fA-F]?)|[1-9a-fA-F][0-9a-fA-F]{1,2})|[2-9a-fA-F][0-9a-fA-F]{2,3} Leading zeroes #If you wish to support leading zeros, this is easy to achieve by putting '0'* in front:
'0'* range '0'-'1024' If the number should have a certain length, with leading zeroes added when necessary, pomsky has a special syntax for this:
range '0000'-'1024' This matches numbers in the specified range with exactly 4 digits, such as 0110 or 0026.
`}),e.add({id:11,href:"/docs/language-tour/references/",title:"References",description:"Matching the same thing more than once",content:`Sometimes it\u0026rsquo;s useful to match the same text as we matched before. For example, to match strings in single or double quotes, we can write
:(['\u0026quot;' \u0026quot;'\u0026quot;]) !['\u0026quot;' \u0026quot;'\u0026quot;]* ::1 This consists of three parts: First, there\u0026rsquo;s a capturing group matching a quote. We then match an arbitrary number of characters that aren\u0026rsquo;t quotes. Finally, there\u0026rsquo;s a ::1 reference. This matches the same text as was captured in capturing group number 1. In other words, if the string started with ", it also has to end with ", and if it started with ', it has to end with '.
Another application is XML tags:
'\u0026lt;' :([word]+) '\u0026gt;' !['\u0026lt;']* '\u0026lt;/' ::1 '\u0026gt;' This is by no means a complete XML parser, but it recognizes an XML tag (without attributes) that doesn\u0026rsquo;t contain other XML tags. For example, it correctly matches \u0026lt;span\u0026gt;Hello world\u0026lt;/span\u0026gt;. With a backreference, it ensures that the closing tag is the same as the opening tag.
Pomsky has three kinds of references:
Numeric references, e.g. ::3, match a capturing group by its number. Named references, e.g. ::name, match a named capturing group by its name. Relative references, e.g. ::-1 or ::+2, match a capturing group relative to the current position. For example, ::-1 matches the previous capturing group, ::+1 matches the next one. Note that some regex engines only support backreferences, not forward references. And even when forward references are supported, the referenced group must have been already matched. I.e., this is not allowed:
# doesn't work! ::1 :('test') However, forward references can be used in repetitions to match what the referenced group captured in the previous repetition:
(::forward | :forward('test') '!')* This matches the text test!test, for example. In the first repetition, the second alternative matches test!, and the text test is captured by the forward capturing group. In the second iteration, the forward reference matches the text test.
`}),e.add({id:12,href:"/docs/language-tour/variables/",title:"Variables",description:"Refactoring expressions so you Don't Repeat Yourself",content:`Variables are a powerful feature that is exclusive to pomsky; because no regex engine offers this functionality, variables in pomsky are \u0026ldquo;inlined\u0026rdquo;, i.e. substituted with their value recursively.
This means that variables don\u0026rsquo;t allow recursion, because otherwise the generated regular expression would have infinite size. But even without recursion, variables are a powerful and useful tool to create more complex expressions.
Variables are declared with the let keyword:
let x = 'hello' | 'world'; The above will emit nothing, because the variable is declared, but not used. It could be used like this:
let x = 'hello' | 'world'; x '!' This compiles to
(?:hello|world)! There can be multiple variable declarations. They can appear in any order, but the pomsky expression using the variables must come last. For example, this is not allowed:
# doesn't work! x '!' let x = 'hello' | 'world'; Declarations can depend on each other, as long as there is no cyclic dependency:
let c = 'test'; let a = b b; let b = c '!'; a Declarations can be nested within a group; in that case, they can only be used within this group. However, variables can be used within a group even if they were declared outside:
let name = 'Max'; ( let greeting = 'Hello'; greeting ', ' name ) greeting # error! In this example, greeting can\u0026rsquo;t be used in the last line because it is only accessible within the group where it was declared.
Nested declarations can have the same name as a declaration outside of the group:
let name = 'Max'; ( let name = 'Sophia'; 'Hello, ' name ) ' and ' name This compiles to
Hello, Sophia and Max `}),e.add({id:13,href:"/docs/language-tour/graphemes/",title:"Graphemes",description:"Matching what represents a single 'character'",content:`Some regex engines support matching a single Unicode grapheme cluster. A grapheme cluster is what comes closest to what we perceive as a character. It can consist of more than one code point. For example, emojis with modifiers (such as different skin tones, genders, etc.) usually consist of multiple code points.
In Pomsky, matching a grapheme cluster is done with Grapheme (abbreviated as G). For example, to match a text with at most 400 characters, you can write
Grapheme{0,400} Grapheme is a built-in variable.
`}),e.add({id:14,href:"/docs/language-tour/regex/",title:"Inline regular expressions",description:"Insert text in the output regex with no escaping",content:`Although Pomsky on its own is very powerful, there might be situations where its syntax is not expressive enough. In these rare situations, Pomsky has an escape hatch: The regex keyword allows specifying an expression that is embedded in the output verbatim, without escaping:
regex 'hello|world?' This emits the following regular expression:
hello|world? Note that this is dangerous and should be used only when absolutely necessary. Pomsky does not parse the content of regex expressions, so it cannot ensure that it is valid.
Regex expressions containing pipes #Pomsky doesn\u0026rsquo;t know whether a regex expression contains pipes, and whether it is necessary to wrap it in a group when embedding it in a larger pomsky expression. For example:
'a' regex 'b|c' What do you expect the output to be? If you think that this should produce a(?:b|c), you are mistaken. The output is:
ab|c To get the expected output, a group must be added:
'a' regex '(?:b|c)' The same can be achieved by adding parentheses outside like this:
'a' (regex 'a|b') Although Pomsky usually removes redundant parentheses, these parentheses are not removed because Pomsky can\u0026rsquo;t tell if they\u0026rsquo;re needed, so it trusts you to add them only when required.
Repeated regex expressions #Pomsky wraps a regex expression in a group if it is followed by a repetition. For example:
regex 'test.'? This returns:
(?:test.)? If this is not desired, include the repetition in the string literal:
regex 'test.?' `}),e.add({id:15,href:"/docs/language-tour/backtracking/",title:"Backtracking",description:"How most regex engines find matches",content:`Pomsky doesn\u0026rsquo;t actually execute your expression. Instead, it transforms the expression into a regex. There are many regex engines for executing them, and Pomsky supports the most popular ones. Most of them happen to be backtracking, which means that they try out different paths in the expression, and when a path is not successful, they \u0026ldquo;backtrack\u0026rdquo; to a position in the string where another path may match.
Consider this example:
'a' 'b'+ 'a'? 'c' | 'a' 'b'+ 'd'? 'd' There are two alternatives, and a backtracking engine will try one after another. If the search string is abbd, it finds the first 'a' then repeats the 'b' three times. Then it expects an optional 'a', but since there\u0026rsquo;s no a at this position, it skips the 'a'. Then it expects a 'c', but there is no c, and as the 'c' is not optional, the match failed, and the regex engine starts over with the other alternative.
Again, the regex engine finds the first 'a', and repeats the 'b' 3 times. Then there\u0026rsquo;s an optional 'd', and since it is greedy, it matches the d from the search string. Now, it expects another 'd', but the whole search string has already been consumed. So the match fails again, and the engine backtracks to the optional 'd'?. This time, the engine decides to skip it, and the search succeeds.
Catastrophic backtracking #Backtracking can be characterized as \u0026ldquo;lots of trial and error\u0026rdquo;. For certain expressions and inputs, backtracking can be extremely slow, often with exponential runtime. One example is this expression:
('x' 'x'*)+ 'y' When matching the string xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx, there are many ways how it can be matched. For example, it could repeat the group only once, or it could match 6 x\u0026rsquo;s in the first repetition, then another 6 in the second repetition, and the rest in the third. And so on. The number of possible combinations is exponential with respect to the search string length. And since the string doesn\u0026rsquo;t match the expression (because it doesn\u0026rsquo;t end with y), a backtracking engine will try out all possible combinations before giving up.
This may be a problem if you\u0026rsquo;re executing the regular expression in a web server, and you\u0026rsquo;re searching a text entered by a user. If the user has bad intentions, they can enter a text that leads to catastrophic backtracking. Then your server is caught in an infinite loop; even if it is multi-threaded, the user can enter the malicious text multiple times, until all threads are busy and your service is unreachable. This is why regular expressions executed in a server or similarly important infrastructure should be resistant to catastrophic backtracking.
The easiest solution is to never use nested repetitions. Repetitions are fine as long as they\u0026rsquo;re only one level deep. Nested repetitions can sometimes also be fine, but this is harder to prove. However, the best solution is to use a regex engine like Rust that uses an NFA and never backtracks. Rust\u0026rsquo;s regex can execute the above expression with the input xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx in less than a millisecond, for which JavaScript would take years.
`}),e.add({id:16,href:"/docs/reference/grammar/",title:"Formal grammar",description:"pomsky' syntax specification",content:`Summary #This document uses pomsky syntax to describe pomsky\u0026rsquo;s syntax. Here\u0026rsquo;s an incomplete summary, which should be enough to read the grammar:
Variables are declared as let var_name = expression;. This assigns expression to the variable var_name.
Verbatim text is wrapped in double quotes ("") or single quotes ('').
A * after a rule indicates that it repeats 0 or more times.
A + after a rule indicates that it repeats 1 or more times.
A ? after a rule indicates that the rule is optional.
Rules can be grouped together by wrapping them in parentheses (()).
Alternative rules are each preceded by a vertical bar (|).
Formal grammar #Comments start with # and end at the end of the same line. Comments and whitespace are ignored; they can be added anywhere.
Expression #let Expression = Statement* OrExpression; let Statement = | LetDeclaration | Modifier; let LetDeclaration = 'let' Name '=' OrExpression ';'; let Modifier = ModifierKeyword BooleanSetting ';'; let ModifierKeyword = | 'enable' | 'disable'; let BooleanSetting = | 'lazy' | 'unicode'; OrExpression #let OrExpression = ('|'? Alternatives)?; let Alternatives = Alternative ('|' Alternative)*; let Alternative = FixExpression+; FixExpression #An expression which can have a prefix or suffix.
let FixExpression = | LookaroundPrefix Expression | AtomExpression RepetitionSuffix?; Lookaround #let LookaroundPrefix = | '!'? '\u0026lt;\u0026lt;' | '!'? '\u0026gt;\u0026gt;'; Repetitions #let RepetitionSuffix = RepetitionCount Quantifier?; let RepetitionCount = | '*' | '+' | '?' | RepetitionBraces; let RepetitionBraces = | '{' Number '}' | '{' Number? ',' Number? '}'; let Quantifier = | 'greedy' | 'lazy'; AtomExpression #let AtomExpression = | Group | String | CharacterSet | InlineRegex | Boundary | Reference | NumberRange | CodePoint | Name | '.'; Group #let Group = GroupKind? '(' Expression ')'; let GroupKind = | ':' Name? | 'atomic'; Note: A group name must be ASCII-only and may not contain underscores. Furthermore, a group name must be no longer than 32 characters. For example:
:underscores_are_invalid() :äöéŧûøIsInvalid() :thisGroupNameIsTooLongUnfortunately() :thisIsAllowed() These restrictions exist because of Java. To make Pomsky behave consistently across regex flavors, we have to use the most restrictive rules for all flavors.
CharacterSet #let CharacterSet = | '!'? '[' '.' ']' # deprecated! | '!'? '[' CharacterSetInner+ ']'; let CharacterSetInner = | Range | String | CodePoint | NonPrintable | Shorthand | UnicodeProperty | PosixClass; let Range = SingleChar '-' SingleChar; let SingleChar = | StringOneChar | CodePoint | NonPrintable; let NonPrintable = | 'n' | 'r' | 't' | 'a' | 'e' | 'f'; let Shorthand = '!'? ShorthandIdent; let ShorthandIdent = | 'w' | 'word' | 'd' | 'digit' | 's' | 'space' | 'h' | 'horiz_space' | 'v' | 'vert_space' | 'l' | 'line_break' let PosixClass = | 'ascii' | 'ascii_alpha' | 'ascii_alnum' | 'ascii_blank' | 'ascii_cntrl' | 'ascii_digit' | 'ascii_graph' | 'ascii_lower' | 'ascii_print' | 'ascii_punct' | 'ascii_space' | 'ascii_upper' | 'ascii_word' | 'ascii_xdigit'; UnicodeProperty #let UnicodeProperty = '!'? Name; Details about supported Unicode properties can be found here.
InlineRegex #let InlineRegex = 'regex' String; Boundary #let Boundary = | '^' | '$' | '!'? '%'; Reference #let Reference = | '::' Name | '::' Sign? Number; let Sign = | '+' | '-'; Note that references must be ASCII-only, so the allowed characters are a-z, A-Z, _, and 0-9. Numbers may not appear the start of the name.
NumberRange #let NumberRange = 'range' String '-' String Base?; let Base = 'base' Number; Note that the strings must contain digits or ASCII letters in the supported range. For example, in base 16, the characters 0123456789abcdefABCDEF are allowed. The base must be between 2 and 36.
Tokens #Tokens (also called terminals) cannot be further divided. There are the following token types used in the above grammar:
Name #Names (or identifiers) consist of a letter or underscore (_), followed by any number of letters, digits and underscores. For example:
# valid identifiers hello i18n _foo_ Gänsefüßchen # invalid identifiers kebab-case 42 👍‍ A letter is any code point with the Alphabetic property, which can be matched in most regex flavors with \\p{Alpha}. A digit is any code point from the Number general categories, which can be matched in most regex flavors with \\pN.
Note that group names have more restrictions than variable names, see above.
Identifiers may not be one of the following reserved words:
U let lazy greedy range base atomic enable disable if else recursion regex test Number #A whole number without a sign and without leading zeros. For example:
# valid numbers 0 1 42 10000 # invalid numbers 042 -30 +30 30.1 10_000 10,000 String #A string is a sequence of code points surrounded by single or double quotes. In double quoted strings, double quotes and backslashes are escaped by preceding them with a backslash. No other escapes are supported: For example:
# valid strings 'test' \u0026quot;test\u0026quot; \u0026quot;C:\\\\User\\\\Dwayne \\\u0026quot;The Rock\\\u0026quot; Johnson\u0026quot; 'C:\\User\\Dwayne \u0026quot;The Rock\u0026quot; Johnson' 'this is a multiline string' \u0026quot;this is a multiline string\u0026quot; # invalid strings \u0026quot;\\n\u0026quot; \u0026quot;\\uFFFF\u0026quot; '\\'' StringOneChar #Same as String, with the limitation that the string must contain exactly one code point or grapheme.
CodePoint #A codepoint consists of U, +, and 1 to 6 hexadecimal digits (0-9, a-f, A-F). It must represent a valid Unicode scalar value. This means that it must be a valid codepoint, but not a UTF-16 surrogate. For example:
# valid codepoints U+0 U+10 U+FFF U+10FFFF U + FF # invalid codepoints U+300000 U+00000001 U+D800 U+FGHI Note that the + may be surrounded by spaces.
Note about this grammar #Even though this grammar is written using Pomsky syntax, it isn\u0026rsquo;t actually accepted by the pomsky compiler, because it uses cyclic variables.
`}),e.add({id:17,href:"/docs/reference/unicode-properties/",title:"Unicode properties",description:"Exhaustive list of Unicode general categories, scripts, blocks and other properties supported by pomsky",content:`Pomsky supports the following kinds of Unicode properties:
General categories Scripts Blocks Other boolean properties However, not all regex engines support all of them. In particular, blocks and other properties are poorly supported.
Categories #Every Unicode code point is in one of the following General Categories:
Letter Mark Number Punctuation Symbol Separator Other Each of these categories is subdivided into smaller categories. More information on Wikipedia.
In Pomsky, you can match against categories in square brackets:
[Uppercase_Letter Mark] Using the abbreviations, the above can be written as
[Lu M] Show all 38 categories Abbr Long Description Lu Uppercase_Letter an uppercase letter Ll Lowercase_Letter a lowercase letter Lt Titlecase_Letter a digraphic character, with first part uppercase LC Cased_Letter Lu | Ll | Lt Lm Modifier_Letter a modifier letter Lo Other_Letter other letters, including syllables and ideographs L Letter Lu | Ll | Lt | Lm | Lo Mn Nonspacing_Mark a nonspacing combining mark (zero advance width) Mc Spacing_Mark a spacing combining mark (positive advance width) Me Enclosing_Mark an enclosing combining mark M Mark Mn | Mc | Me Nd Decimal_Number a decimal digit Nl Letter_Number a letterlike numeric character No Other_Number a numeric character of other type N Number Nd | Nl | No Pc Connector_Punctuation a connecting punctuation mark, like a tie Pd Dash_Punctuation a dash or hyphen punctuation mark Ps Open_Punctuation an opening punctuation mark (of a pair) Pe Close_Punctuation a closing punctuation mark (of a pair) Pi Initial_Punctuation an initial quotation mark Pf Final_Punctuation a final quotation mark Po Other_Punctuation a punctuation mark of other type P Punctuation Pc | Pd | Ps | Pe | Pi | Pf | Po Sm Math_Symbol a symbol of mathematical use Sc Currency_Symbol a currency sign Sk Modifier_Symbol a non-letterlike modifier symbol So Other_Symbol a symbol of other type S Symbol Sm | Sc | Sk | So Zs Space_Separator a space character (of various non-zero widths) Zl Line_Separator U+2028 LINE SEPARATOR only Zp Paragraph_Separator U+2029 PARAGRAPH SEPARATOR only Z Separator Zs | Zl | Zp Cc Control a C0 or C1 control code Cf Format a format control character Cs Surrogate a surrogate code point
⚠️ not supported in Rust Co Private_Use a private-use character Cn Unassigned a reserved unassigned code point or a noncharacter C Other Cc | Cf | Cs | Co | Cn Support # PCRE JavaScript Java Ruby Rust .NET Python ✅ ✅ ✅ ✅ ✅ ✅ ⛔ Rust does not support the Surrogate category, because it is always Unicode aware and UTF-16 surrogates are not valid Unicode scalar values.
Scripts #A script is a collection of code points used to represent textual information in one or more writing systems.
As with categories, code points can only be assigned to a single script. Code points used in multiple scripts are therefore assigned to the special script Common. More information on Wikipedia.
Show all 164 scripts Abbr Long / Notes Adlm Adlam Aghb Caucasian_Albanian Ahom Ahom Arab Arabic Armi Imperial_Aramaic Armn Armenian Avst Avestan Bali Balinese Bamu Bamum Bass Bassa_Vah Batk Batak Beng Bengali Bhks Bhaiksuki Bopo Bopomofo Brah Brahmi Brai Braille Bugi Buginese Buhd Buhid Cakm Chakma Cans Canadian_Aboriginal Cari Carian Cham Cham Cher Cherokee Chrs Chorasmian Copt Coptic, Qaac Cpmn Cypro_Minoan Cprt Cypriot Cyrl Cyrillic Deva Devanagari Diak Dives_Akuru Dogr Dogra Dsrt Deseret Dupl Duployan Egyp Egyptian_Hieroglyphs Elba Elbasan Elym Elymaic Ethi Ethiopic Geor Georgian Glag Glagolitic Gong Gunjala_Gondi Gonm Masaram_Gondi Goth Gothic Gran Grantha Grek Greek Gujr Gujarati Guru Gurmukhi Hang Hangul Hani Han Hano Hanunoo Hatr Hatran Hebr Hebrew Hira Hiragana Hluw Anatolian_Hieroglyphs Hmng Pahawh_Hmong Hmnp Nyiakeng_Puachue_Hmong Hung Old_Hungarian Ital Old_Italic Java Javanese Kali Kayah_Li Kana Katakana Kawi Kawi
⚠️ not supported by PCRE, Java and Ruby Khar Kharoshthi Khmr Khmer Khoj Khojki Kits Khitan_Small_Script Knda Kannada Kthi Kaithi Lana Tai_Tham Laoo Lao Latn Latin Lepc Lepcha Limb Limbu Lina Linear_A Linb Linear_B Lisu Lisu Lyci Lycian Lydi Lydian Mahj Mahajani Maka Makasar Mand Mandaic Mani Manichaean Marc Marchen Medf Medefaidrin Mend Mende_Kikakui Merc Meroitic_Cursive Mero Meroitic_Hieroglyphs Mlym Malayalam Modi Modi Mong Mongolian Mroo Mro Mtei Meetei_Mayek Mult Multani Mymr Myanmar Nagm Nag_Mundari
⚠️ not supported by PCRE, Java and Ruby Nand Nandinagari Narb Old_North_Arabian Nbat Nabataean Newa Newa Nkoo Nko Nshu Nushu Ogam Ogham Olck Ol_Chiki Orkh Old_Turkic Orya Oriya Osge Osage Osma Osmanya Ougr Old_Uyghur Palm Palmyrene Pauc Pau_Cin_Hau Perm Old_Permic Phag Phags_Pa Phli Inscriptional_Pahlavi Phlp Psalter_Pahlavi Phnx Phoenician Plrd Miao Prti Inscriptional_Parthian Rjng Rejang Rohg Hanifi_Rohingya Runr Runic Samr Samaritan Sarb Old_South_Arabian Saur Saurashtra Sgnw SignWriting Shaw Shavian Shrd Sharada Sidd Siddham Sind Khudawadi Sinh Sinhala Sogd Sogdian Sogo Old_Sogdian Sora Sora_Sompeng Soyo Soyombo Sund Sundanese Sylo Syloti_Nagri Syrc Syriac Tagb Tagbanwa Takr Takri Tale Tai_Le Talu New_Tai_Lue Taml Tamil Tang Tangut Tavt Tai_Viet Telu Telugu Tfng Tifinagh Tglg Tagalog Thaa Thaana Thai Thai Tibt Tibetan Tirh Tirhuta Tnsa Tangsa Toto Toto Ugar Ugaritic Vaii Vai Vith Vithkuqi Wara Warang_Citi Wcho Wancho Xpeo Old_Persian Xsux Cuneiform Yezi Yezidi Yiii Yi Zanb Zanabazar_Square Zinh Inherited Zyyy Common Zzzz Unknown
⚠️ not supported by Rust Support # PCRE JavaScript Java Ruby Rust .NET Python ✅ ✅ ✅ ✅ ✅ ✅ ⛔ Kawi and Nag_Mundari, added in Unicode 15.0, are not yet supported in PCRE, Java and Ruby.
Zzzz (Unknown) is not supported in Rust.
JavaScript supports all scripts as of Unicode 15.0.
Blocks #The Unicode character set is divided into blocks of consecutive code points that usually belong to the same script or serve a similar purpose.
There are often multiple blocks for a script. For example, there are 10 designated blocks for Latin code points: Basic_Latin, Latin_1_Supplement, Latin_Extended_Additional, and Latin_Extended_A through Latin_Extended_G. Furthermore, many blocks contain two or more scripts, which is not always clear from the name. For example, Latin_Extended_E includes a Greek code point.
It is almost always better to use the script rather than the block, but Pomsky still supports blocks using the In prefix:
# matches code points in the \`Basic_Latin\` block [InBasic_Latin] Show all 328 blocks Names Adlam Aegean_Numbers Ahom Alchemical, Alchemical_Symbols Alphabetic_PF, Alphabetic_Presentation_Forms Anatolian_Hieroglyphs Ancient_Greek_Music, Ancient_Greek_Musical_Notation Ancient_Greek_Numbers Ancient_Symbols Arabic Arabic_Ext_A, Arabic_Extended_A Arabic_Ext_B, Arabic_Extended_B Arabic_Ext_C, Arabic_Extended_C Arabic_Math, Arabic_Mathematical_Alphabetic_Symbols Arabic_PF_A, Arabic_Presentation_Forms_A Arabic_PF_B, Arabic_Presentation_Forms_B Arabic_Sup, Arabic_Supplement Armenian Arrows ASCII, Basic_Latin Avestan Balinese Bamum Bamum_Sup, Bamum_Supplement Bassa_Vah Batak Bengali Bhaiksuki Block_Elements Bopomofo Bopomofo_Ext, Bopomofo_Extended Box_Drawing Brahmi Braille, Braille_Patterns Buginese Buhid Byzantine_Music, Byzantine_Musical_Symbols Carian Caucasian_Albanian Chakma Cham Cherokee Cherokee_Sup, Cherokee_Supplement Chess_Symbols Chorasmian CJK, CJK_Unified_Ideographs CJK_Compat, CJK_Compatibility CJK_Compat_Forms, CJK_Compatibility_Forms CJK_Compat_Ideographs, CJK_Compatibility_Ideographs CJK_Compat_Ideographs_Sup, CJK_Compatibility_Ideographs_Supplement CJK_Ext_A, CJK_Unified_Ideographs_Extension_A CJK_Ext_B, CJK_Unified_Ideographs_Extension_B CJK_Ext_C, CJK_Unified_Ideographs_Extension_C CJK_Ext_D, CJK_Unified_Ideographs_Extension_D CJK_Ext_E, CJK_Unified_Ideographs_Extension_E CJK_Ext_F, CJK_Unified_Ideographs_Extension_F CJK_Ext_G, CJK_Unified_Ideographs_Extension_G CJK_Ext_H, CJK_Unified_Ideographs_Extension_H CJK_Radicals_Sup, CJK_Radicals_Supplement CJK_Strokes CJK_Symbols, CJK_Symbols_And_Punctuation Compat_Jamo, Hangul_Compatibility_Jamo Control_Pictures Coptic Coptic_Epact_Numbers Counting_Rod, Counting_Rod_Numerals Cuneiform Cuneiform_Numbers, Cuneiform_Numbers_And_Punctuation Currency_Symbols Cypriot_Syllabary Cypro_Minoan Cyrillic Cyrillic_Ext_A, Cyrillic_Extended_A Cyrillic_Ext_B, Cyrillic_Extended_B Cyrillic_Ext_C, Cyrillic_Extended_C Cyrillic_Ext_D, Cyrillic_Extended_D Cyrillic_Sup, Cyrillic_Supplement, Cyrillic_Supplementary Deseret Devanagari Devanagari_Ext, Devanagari_Extended Devanagari_Ext_A, Devanagari_Extended_A Diacriticals, Combining_Diacritical_Marks Diacriticals_Ext, Combining_Diacritical_Marks_Extended Diacriticals_For_Symbols, Combining_Diacritical_Marks_For_Symbols, Combining_Marks_For_Symbols Diacriticals_Sup, Combining_Diacritical_Marks_Supplement Dingbats Dives_Akuru Dogra Domino, Domino_Tiles Duployan Early_Dynastic_Cuneiform Egyptian_Hieroglyph_Format_Controls Egyptian_Hieroglyphs Elbasan Elymaic Emoticons Enclosed_Alphanum, Enclosed_Alphanumerics Enclosed_Alphanum_Sup, Enclosed_Alphanumeric_Supplement Enclosed_CJK, Enclosed_CJK_Letters_And_Months Enclosed_Ideographic_Sup, Enclosed_Ideographic_Supplement Ethiopic Ethiopic_Ext, Ethiopic_Extended Ethiopic_Ext_A, Ethiopic_Extended_A Ethiopic_Ext_B, Ethiopic_Extended_B Ethiopic_Sup, Ethiopic_Supplement Geometric_Shapes Geometric_Shapes_Ext, Geometric_Shapes_Extended Georgian Georgian_Ext, Georgian_Extended Georgian_Sup, Georgian_Supplement Glagolitic Glagolitic_Sup, Glagolitic_Supplement Gothic Grantha Greek, Greek_And_Coptic Greek_Ext, Greek_Extended Gujarati Gunjala_Gondi Gurmukhi Half_And_Full_Forms, Halfwidth_And_Fullwidth_Forms Half_Marks, Combining_Half_Marks Hangul, Hangul_Syllables Hanifi_Rohingya Hanunoo Hatran Hebrew High_PU_Surrogates, High_Private_Use_Surrogates High_Surrogates Hiragana IDC, Ideographic_Description_Characters Ideographic_Symbols, Ideographic_Symbols_And_Punctuation Imperial_Aramaic Indic_Number_Forms, Common_Indic_Number_Forms Indic_Siyaq_Numbers Inscriptional_Pahlavi Inscriptional_Parthian IPA_Ext, IPA_Extensions Jamo, Hangul_Jamo Jamo_Ext_A, Hangul_Jamo_Extended_A Jamo_Ext_B, Hangul_Jamo_Extended_B Javanese Kaithi Kaktovik_Numerals Kana_Ext_A, Kana_Extended_A Kana_Ext_B, Kana_Extended_B Kana_Sup, Kana_Supplement Kanbun Kangxi, Kangxi_Radicals Kannada Katakana Katakana_Ext, Katakana_Phonetic_Extensions Kawi Kayah_Li Kharoshthi Khitan_Small_Script Khmer Khmer_Symbols Khojki Khudawadi Lao Latin_1_Sup, Latin_1_Supplement , Latin_1 Latin_Ext_A, Latin_Extended_A Latin_Ext_Additional, Latin_Extended_Additional Latin_Ext_B, Latin_Extended_B Latin_Ext_C, Latin_Extended_C Latin_Ext_D, Latin_Extended_D Latin_Ext_E, Latin_Extended_E Latin_Ext_F, Latin_Extended_F Latin_Ext_G, Latin_Extended_G Lepcha Letterlike_Symbols Limbu Linear_A Linear_B_Ideograms Linear_B_Syllabary Lisu Lisu_Sup, Lisu_Supplement Low_Surrogates Lycian Lydian Mahajani Mahjong, Mahjong_Tiles Makasar Malayalam Mandaic Manichaean Marchen Masaram_Gondi Math_Alphanum, Mathematical_Alphanumeric_Symbols Math_Operators, Mathematical_Operators Mayan_Numerals Medefaidrin Meetei_Mayek Meetei_Mayek_Ext, Meetei_Mayek_Extensions Mende_Kikakui Meroitic_Cursive Meroitic_Hieroglyphs Miao Misc_Arrows, Miscellaneous_Symbols_And_Arrows Misc_Math_Symbols_A, Miscellaneous_Mathematical_Symbols_A Misc_Math_Symbols_B, Miscellaneous_Mathematical_Symbols_B Misc_Pictographs, Miscellaneous_Symbols_And_Pictographs Misc_Symbols, Miscellaneous_Symbols Misc_Technical, Miscellaneous_Technical Modi Modifier_Letters, Spacing_Modifier_Letters Modifier_Tone_Letters Mongolian Mongolian_Sup, Mongolian_Supplement Mro Multani Music, Musical_Symbols Myanmar Myanmar_Ext_A, Myanmar_Extended_A Myanmar_Ext_B, Myanmar_Extended_B Nabataean Nag_Mundari Nandinagari NB, No_Block New_Tai_Lue Newa NKo Number_Forms Nushu Nyiakeng_Puachue_Hmong OCR, Optical_Character_Recognition Ogham Ol_Chiki Old_Hungarian Old_Italic Old_North_Arabian Old_Permic Old_Persian Old_Sogdian Old_South_Arabian Old_Turkic Old_Uyghur Oriya Ornamental_Dingbats Osage Osmanya Ottoman_Siyaq_Numbers Pahawh_Hmong Palmyrene Pau_Cin_Hau Phags_Pa Phaistos, Phaistos_Disc Phoenician Phonetic_Ext, Phonetic_Extensions Phonetic_Ext_Sup, Phonetic_Extensions_Supplement Playing_Cards Psalter_Pahlavi PUA, Private_Use_Area, Private_Use Punctuation, General_Punctuation Rejang Rumi, Rumi_Numeral_Symbols Runic Samaritan Saurashtra Sharada Shavian Shorthand_Format_Controls Siddham Sinhala Sinhala_Archaic_Numbers Small_Forms, Small_Form_Variants Small_Kana_Ext, Small_Kana_Extension Sogdian Sora_Sompeng Soyombo Specials Sundanese Sundanese_Sup, Sundanese_Supplement Sup_Arrows_A, Supplemental_Arrows_A Sup_Arrows_B, Supplemental_Arrows_B Sup_Arrows_C, Supplemental_Arrows_C Sup_Math_Operators, Supplemental_Mathematical_Operators Sup_PUA_A, Supplementary_Private_Use_Area_A Sup_PUA_B, Supplementary_Private_Use_Area_B Sup_Punctuation, Supplemental_Punctuation Sup_Symbols_And_Pictographs, Supplemental_Symbols_And_Pictographs Super_And_Sub, Superscripts_And_Subscripts Sutton_SignWriting Syloti_Nagri Symbols_And_Pictographs_Ext_A, Symbols_And_Pictographs_Extended_A Symbols_For_Legacy_Computing Syriac Syriac_Sup, Syriac_Supplement Tagalog Tagbanwa Tags Tai_Le Tai_Tham Tai_Viet Tai_Xuan_Jing, Tai_Xuan_Jing_Symbols Takri Tamil Tamil_Sup, Tamil_Supplement Tangsa Tangut Tangut_Components Tangut_Sup, Tangut_Supplement Telugu Thaana Thai Tibetan Tifinagh Tirhuta Toto Transport_And_Map, Transport_And_Map_Symbols UCAS, Unified_Canadian_Aboriginal_Syllabics, Canadian_Syllabics UCAS_Ext, Unified_Canadian_Aboriginal_Syllabics_Extended UCAS_Ext_A, Unified_Canadian_Aboriginal_Syllabics_Extended_A Ugaritic Vai Vedic_Ext, Vedic_Extensions Vertical_Forms Vithkuqi VS, Variation_Selectors VS_Sup, Variation_Selectors_Supplement Wancho Warang_Citi Yezidi Yi_Radicals Yi_Syllables Yijing, Yijing_Hexagram_Symbols Zanabazar_Square Znamenny_Music, Znamenny_Musical_Notation Support # PCRE JavaScript Java Ruby Rust .NET Python ✅ ⛔ ✅ ✅ ✅ ✅ ⛔ Java doesn\u0026rsquo;t support the following blocks:
Arabic_Extended_C CJK_Unified_Ideographs_Extension_H Combining_Diacritical_Marks_For_Symbols Cyrillic_Extended_D Cyrillic_Supplementary Devanagari_Extended_A Greek_And_Coptic Kaktovik_Numerals No_Block Ruby doesn\u0026rsquo;t support the following blocks:
Arabic_Extended_C CJK_Unified_Ideographs_Extension_H Cyrillic_Extended_D Devanagari_Extended_A Kaktovik_Numerals PCRE and Rust both support all blocks as of Unicode 15.0.
Other properties #There are a number of boolean properties (meaning they are either Yes or No), which you can use in Pomsky by simply putting them in square brackets:
# match code points with Diacritic=Yes [Diacritic] Show all 53 other properties Abbr Long ASCII ASCII AHex ASCII_Hex_Digit Alpha Alphabetic Any Any Assigned Assigned Bidi_C Bidi_Control Bidi_M Bidi_Mirrored CI Case_Ignorable Cased Cased CWCF Changes_When_Casefolded CWCM Changes_When_Casemapped CWL Changes_When_Lowercased CWKCF Changes_When_NFKC_Casefolded CWT Changes_When_Titlecased CWU Changes_When_Uppercased Dash Dash DI Default_Ignorable_Code_Point Dep Deprecated Dia Diacritic Emoji Emoji EComp Emoji_Component EMod Emoji_Modifier EBase Emoji_Modifier_Base EPres Emoji_Presentation ExtPict Extended_Pictographic Ext Extender Gr_Base Grapheme_Base Gr_Ext Grapheme_Extend Hex Hex_Digit IDSB IDS_Binary_Operator IDST IDS_Trinary_Operator IDC ID_Continue IDS ID_Start Ideo Ideographic Join_C Join_Control LOE Logical_Order_Exception Lower Lowercase Math Math NChar Noncharacter_Code_Point Pat_Syn Pattern_Syntax Pat_WS Pattern_White_Space QMark Quotation_Mark Radical Radical RI Regional_Indicator STerm Sentence_Terminal SD Soft_Dotted Term Terminal_Punctuation UIdeo Unified_Ideograph Upper Uppercase VS Variation_Selector space White_Space XIDC XID_Continue XIDS XID_Start Support # PCRE JavaScript Java Ruby Rust .NET Python ✅ ✅ ⛔ ✅ ✅ ✅ ⛔ PCRE doesn\u0026rsquo;t support the following blocks:
Assigned Changes_When_NFKC_Casefolded Ruby doesn\u0026rsquo;t support the following blocks:
Bidi_Mirrored Changes_When_NFKC_Casefolded Rust doesn\u0026rsquo;t support the following blocks:
Changes_When_NFKC_Casefolded JavaScript supports all boolean properties as of Unicode 15.0.
`}),e.add({id:18,href:"/docs/reference/built-in-variables/",title:"Built-in variables",description:"Variables provided by pomsky out of the box",content:"There are currently 6 built-in variables:\nGrapheme matches a single extended grapheme cluster. It compiles to the regex \\X. Note that this functionality is not available in all regex flavors. G is an alias for Grapheme Codepoint matches a single Unicode code point. It compiles to the regex [\\s\\S]. C is an alias for Codepoint Start: Matches the start of the string. Equivalent to ^. End: Matches the end of the string. Equivalent to $. "}),e.add({id:19,href:"/docs/reference/security/",title:"Security",description:"Advice how to use pomsky securely",content:`If you intend to compile or execute pomsky expressions on a web server or other critical infrastructure, follow this advice, so you don\u0026rsquo;t end up vulnerable to attacks.
A billion laughs #The most important advice is to never compile an untrusted pomsky expression, since doing that may make you vulnerable for denial of service attacks. Here\u0026rsquo;s a simple example:
let lol = 'lol'; let lol1 = lol lol lol lol lol lol lol lol lol lol; let lol2 = lol1 lol1 lol1 lol1 lol1 lol1 lol1 lol1 lol1 lol1; let lol3 = lol2 lol2 lol2 lol2 lol2 lol2 lol2 lol2 lol2 lol2; let lol4 = lol3 lol3 lol3 lol3 lol3 lol3 lol3 lol3 lol3 lol3; let lol5 = lol4 lol4 lol4 lol4 lol4 lol4 lol4 lol4 lol4 lol4; let lol6 = lol5 lol5 lol5 lol5 lol5 lol5 lol5 lol5 lol5 lol5; let lol7 = lol6 lol6 lol6 lol6 lol6 lol6 lol6 lol6 lol6 lol6; let lol8 = lol7 lol7 lol7 lol7 lol7 lol7 lol7 lol7 lol7 lol7; let lol9 = lol8 lol8 lol8 lol8 lol8 lol8 lol8 lol8 lol8 lol8; lol9 What does this expression do? It evaluates the variable lol9, which expands to the lol8 variable 10 times, each of which expands to lol7 10 times, and so on. This exploit, called the Billion Laughs attack, produces the word lol a 1,000,000,000 times, which takes full 5 minutes to compile on my laptop.
If you only compile pomsky expressions you wrote yourself (or someone you trust), this is not a problem, since it is quite unlikely to write something like the above by accident. Furthermore, it is impossible to run into an infinite loop since pomsky forbids recursive variable declarations.
Backtracking #Just like you shouldn\u0026rsquo;t compile untrusted pomsky expressions, you also shouldn\u0026rsquo;t execute an untrusted regex. The reason for this is that most regex engines are backtracking, which has (worst-case) exponential runtime performance. A regex created with not enough care or by a bad actor can easily take down a NodeJS server if the server naively matches a large body of text against the regex.
What does this mean for pomsky? Unless you use RE2 or Rust\u0026rsquo;s regex crate (which never backtrack), Pomsky expressions are just as susceptible to catastrophic backtracking as hand-written regexes. Therefore, don\u0026rsquo;t execute untrusted regexes on critical infrastructure.
A million ranges #Another thing to watch out for are range expressions: Since the complexity of compiling range expressions is exponential, compiling large ranges can take unusually long:
# all unsigned 64-bit integers range '0'-'18446744073709551616' The above pomsky takes 70 milliseconds on my laptop to compile. But add 4 digits and it\u0026rsquo;s over a second. This is already remedied by default, since ranges can by default be at most 6 digits long, or 12 digits in the CLI. Be careful if you override this default.
This limit is not sufficient, though: It is easy to generate an expression containing a million ranges each with 6 digits. This takes 45 seconds to compile on my laptop.
Hardening pomsky #If you intend to compile pomsky expressions on a web server, but not execute the resulting regex, there are a few things you can do to stay safe:
Disable the range feature and variables Limit the length of the pomsky. Limit the number of HTTP requests a user can make per minute Run the pomsky compiler in a separate thread and stop the thread if pomsky doesn\u0026rsquo;t complete in a certain time frame I make no guarantees whether these suggestions are sufficient to protect your service.
`}),e.add({id:20,href:"/docs/reference/comparison/",title:"Comparison with other projects",description:"See how pomsky compares to similar projects",content:`This wiki has a list of projects with similar goals to Pomsky. Here\u0026rsquo;s a list of the most popular projects:
⚠️ Disclaimer that as the maintainer of Pomsky, I am obviously biased. If you find any incorrect or misleading information, please open an issue. Project Types GitHub Melody Transpiled Pomsky Transpiled Egg Expressions Transpiled
App: Oil shell Rx Expressions Transpiled
App: Emacs Raku Grammars App: Raku Rosie App: Rosie SRL DSL: PHP Super Expressive DSL: JS Verbal Expressions DSL: JS Swift RegexBuilder DSL: Swift Since this content is likely to get out of date, I encourage you to update it.
Types #Transpiled #These languages are transpiled to \u0026ldquo;normal\u0026rdquo; regular expressions and can therefore be used anywhere. They usually have command-line interface to compile expressions.
Application specific #Some regex languages are specific to a certain application or programming language. For example, Raku grammars can only be used in Raku; egg expressions are transpiled, but they are only available in the Oil shell.
DSLs #DSLs (domain-specific languages) are languages that are embedded in another language using the host language\u0026rsquo;s syntax. For example, Verbal Expressions uses JavaScript methods:
const tester = VerEx() .startOfLine() .then('http') .maybe('s') .then('://') .maybe('www.') .anythingBut(' ') .endOfLine() This page currently only discusses transpiled languages, but I welcome contributions.
Compatibility #Let\u0026rsquo;s see what Regex flavors are supported by transpiled languages.
Flavor Melody Pomsky Egg Expr. Rx Expr. ERE ✅ ✅ ECMAScript ✅ ✅ PCRE ✅* ✅ .NET ✅* ✅ Java ✅* ✅ Ruby ✅* ✅ Python ✅ Rust ✅ *Melody can only emit ECMAScript regexes, but they also happen to be compatible with several other flavors.
Explanation of the flavors # ERE (extended regular expressions) are used by tools such as GNU grep and awk. Because ERE supports only the most basic features, it is mostly forward compatible with other regex flavors.
ECMAScript is the syntax used in JavaScript and related languages (TypeScript, Elm, Dart, etc.) that are compiled to JS.
PCRE (an acronym for \u0026ldquo;Perl compatible regular expression\u0026rdquo;) is the syntax used by the PCRE2 regex engine, which is the default in at least Crystal, Delphi, Elixir, Erlang, Hack, Julia, PHP, R and Vala. It\u0026rsquo;s also a popular choice in other languages like C and C++ and is used in many applications such as the Apache server, nginx, MariaDB, MongoDB, and optionally in GNU grep.
.NET refers to the Regex class in .NET languages such as C# and F#.
Java refers to the Pattern class in Java\u0026rsquo;s standard library. Equivalent to Kotlin\u0026rsquo;s and Scala\u0026rsquo;s regular expressions.
Ruby refers to built-in regular expressions in Ruby.
Python refers to Pythons re module. Note that Python 3 is required for good Unicode support.
Rust refers to Rust\u0026rsquo;s popular regex crate (used by ripgrep)
Many more flavors exist, which are not (or only partially) supported by Pomsky and other languages.
Features #Let\u0026rsquo;s see what Regex features are supported by languages that are transpiled to regular expressions.
Basic regex features # Feature Melody Pomsky Egg Expr. Rx Expr. Greedy repetition ✅ ✅ ✅ ✅ Lazy repetition ✅ ✅ ✅ ✅ Dot ✅ ✅ ✅ ✅ Character escape ✅ ✅ ✅ ✅ Character class ✅ ✅ ✅ ✅ Anchor ✅ ✅ ✅ ✅ Word boundary ✅ ✅ ✅ ✅ Negated word boundary ✅ ✅ ✅ ✅ Character range partly* ✅ ✅ ✅ Character set ✅ ✅ ✅ Negated character set partly* ✅ ✅ ✅ Capturing group ✅ ✅ ✅ ✅ Alternation ✅ ✅ ✅ ✅ POSIX class ✅ ✅ ✅ Non-capturing group ✅ ✅ ✅ *Character ranges and negated sets in Melody only support ASCII letters, digits and a few special characters.
Advanced features # Feature Melody Pomsky Egg Expr. Rx Expr. Variable/macro ✅ ✅ ✅ ✅ Line comment ✅ ✅ ✅ ✅ Block comment ✅ Code point ✅ ✅ Lookaround ✅ ✅ Named capturing group ✅ ✅ ✅ Backreference ✅ ✅ Named backreference ✅ Relative backreference ✅ Unicode category ✅ ✅ Unicode script/block ✅ partly Other Unicode property ✅ Any code point partly* ✅ partly* partly* Any grapheme ✅ Atomic group ✅ Character set intersection ✅ Character set subtraction Possessive quantifier Conditional Recursion Modifier Inline regex ✅ ✅ Optimization some** Note that Melody and Pomsky support inline regexes. Because of this, all Regex features are technically supported in Melody and Pomsky, but using inline regexes may be less ergonomic and more dangerous to use than properly supported features.
*All languages can match a code point with the dot, if multiline mode is enabled in the regex engine.
**Pomsky can currently optimize repetitions, remove redundant or empty groups and deduplicate code points in character sets. More optimizations are planned.
Tooling # Tool Melody Pomsky Egg Expr. Rx Expr. CLI ✅ ✅ REPL ✅ ✅ Online playground ✅ ✅ VSCode extension ✅ IntelliJ extension ✅ JavaScript bunder Babel Vite,
Rollup,
ESBuild,
Webpack Rust macro ✅ Linter Formatter Language integrations #Packages # Tool Melody Pomsky Homebrew ✅ ✅ AUR ✅ ✅ Nix ✅ ✅ GitHub release binary (Apple) ✅ ✅ GitHub release binary (Windows) ✅ GitHub release binary (Linux) ✅ Node module ✅ ✅ Python module ✅ IDE features # Feature Melody Pomsky Syntax highlighting ✅ ✅ Error highlighting ✅ Code folding ✅1 ✅1 Auto indentation ✅ ✅ Snippets ✅ ✅ Matching brackets and quotes ✅2 ✅ Keyword autocomplete ✅2 ✅ Variable autocomplete ✅3 Backreference autocomplete Character class autocomplete ✅ Unicode property autocomplete ✅ Hover tooltips Apply suggestions Share link (playground) ✅ ✅ 1 indentation based
2 works in playground VSCode, but not in the playground
3 does not take scopes into account
Found a mistake? Please fix it on GitHub.
`}),e.add({id:21,href:"/docs/examples/numbers/",title:"Example: Numbers",description:"Rational numbers in decimal notation with optional separating commas",content:`This regular expression matches rational numbers in decimal notation with optional separating commas:
[-+]??\\b(?:0|[1-9](?:,??[0-9])*)(?:\\.[0-9]+)?\\b Equivalent pomsky expression:
['-+']? % ('0' | ['1'-'9'] (','? ['0'-'9'])*) ('.' ['0'-'9']+)? % `}),e.add({id:22,href:"/docs/examples/passwords/",title:"Example: Passwords",description:"Test if password satisfies strength requirements",content:`Here\u0026rsquo;s a regular expression that tests if a string contains at least one uppercase letter, lowercase letter, digit and punctuation/symbol code point, and is at least 8 code points long:
^(?=[\\S\\s]*?\\d)(?=[\\S\\s]*?\\p{Ll})(?=[\\S\\s]*?\\p{Lu})(?=[\\S\\s]*?[\\pP\\pS])[\\S\\s]{8} Equivalent pomsky expression:
^ (\u0026gt;\u0026gt; C* [digit]) (\u0026gt;\u0026gt; C* [Ll]) (\u0026gt;\u0026gt; C* [Lu]) (\u0026gt;\u0026gt; C* [P S]) C{8} `}),e.add({id:23,href:"/docs/examples/java-idents/",title:"Example: Java Identifiers",description:"Pomsky expression matching a Java identifier",content:`Regex matching a Java identifier:
[\\p{Connector_Punctuation}\\p{Currency_Symbol}\\p{Mark}\\p{Alphabetic}][\\p{Connector_Punctuation}\\p{Currency_Symbol}\\p{Mark}\\p{Alphabetic}\\p{Numeric}]* With abbreviations:
[\\p{Pc}\\p{Sc}\\p{M}\\p{Alpha}][\\p{Pc}\\p{Sc}\\p{M}\\p{Alpha}\\p{Numeric}]* And as a pomsky:
[Pc Sc M Alpha] [Pc Sc M Alpha Numeric]* `}),e.add({id:24,href:"/docs/examples/emails/",title:"Example: Email Addresses",description:"Match an RFC 5322 compliant email address",content:"This StackOverflow answer contains a massive regular expression for matching any RFC 5322 compliant email address:\n(?:[a-z0-9!#$%\u0026amp;'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%\u0026amp;'*+/=?^_`{|}~-]+)*|\u0026quot;(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21\\x23-\\x5b\\x5d-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])*\u0026quot;)@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\\[(?:(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9]))\\.){3}(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9])|[a-z0-9-]*[a-z0-9]:(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21-\\x5a\\x53-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])+)\\]) If your regex engine supports insiginificant whitespace mode (?x), it can be written like this:\n(?x) (?: [a-z0-9!#$%\u0026amp;'*+/=?^_`{|}~-]+ (?: \\. [a-z0-9!#$%\u0026amp;'*+/=?^_`{|}~-]+ )* | \u0026quot; (?: [\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21\\x23-\\x5b\\x5d-\\x7f] | \\\\ [\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f] )* \u0026quot; ) @ (?: (?: [a-z0-9] (?: [a-z0-9-]* [a-z0-9] )? \\. )+ [a-z0-9] (?: [a-z0-9-]* [a-z0-9] )? | \\[ (?: (?: (2 (5 [0-5] | [0-4] [0-9]) | 1 [0-9] [0-9] | [1-9]? [0-9]) ) \\. ){3} (?: (2 (5 [0-5] | [0-4] [0-9]) | 1 [0-9] [0-9] | [1-9]? [0-9]) | [a-z0-9-]* [a-z0-9] : (?: [\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21-\\x5a\\x53-\\x7f] | \\\\ [\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f] )+ ) \\] ) Here\u0026rsquo;s a straightforward translation into pomsky:\n( | ['a'-'z' '0'-'9' \u0026quot;!#$%\u0026amp;'*+/=?^_`{|}~-\u0026quot;]+ ('.' ['a'-'z' '0'-'9' \u0026quot;!#$%\u0026amp;'*+/=?^_`{|}~-\u0026quot;]+ )* | '\u0026quot;' ( [U+01-U+08 U+0b U+0c U+0e-U+1f U+21 U+23-U+5b U+5d-U+7f] | '\\' [U+01-U+09 U+0b U+0c U+0e-U+7f] )* '\u0026quot;' ) '@' ( | ( ['a'-'z' '0'-'9'] ( ['a'-'z' '0'-'9' '-']* ['a'-'z' '0'-'9'] )? '.' )+ ['a'-'z' '0'-'9'] ( ['a'-'z' '0'-'9' '-']* ['a'-'z' '0'-'9'] )? | '[' (:(range '0'-'255') '.'){3} ( | :(range '0'-'255') | ['a'-'z' '0'-'9' '-']* ['a'-'z' '0'-'9'] ':' ( | [U+01-U+08 U+0b U+0c U+0e-U+1f U+21-U+5a U+53-U+7f] | '\\' [U+01-U+09 U+0b U+0c U+0e-U+7f] )+ ) ']' ) Notice how the complex logic for matching a number between \u0026lsquo;0\u0026rsquo; and \u0026lsquo;255\u0026rsquo; is replaced by a simple range expression in pomsky.\nWe can also write the above as follows using variables:\nlet char_before_at = ['a'-'z' '0'-'9' \u0026quot;!#$%\u0026amp;'*+/=?^_`{|}~-\u0026quot;]; let quoted_char_before_at = [U+01-U+08 U+0b U+0c U+0e-U+1f U+21 U+23-U+5b U+5d-U+7f]; let escaped_char_before_at = '\\' [U+01-U+09 U+0b U+0c U+0e-U+7f]; let lower_digit = ['a'-'z' '0'-'9']; let lower_digit_dash = ['a'-'z' '0'-'9' '-']; let port_digit = [U+01-U+08 U+0b U+0c U+0e-U+1f U+21-U+5a U+53-U+7f]; let escaped_port_char = '\\' [U+01-U+09 U+0b U+0c U+0e-U+7f]; ( | char_before_at+ ('.' char_before_at+)* | '\u0026quot;' (quoted_char_before_at | escaped_char_before_at)* '\u0026quot;' ) '@' ( | (lower_digit (lower_digit_dash* lower_digit)? '.')+ lower_digit (lower_digit_dash* lower_digit)? | '[' (:(range '0'-'255') '.'){3} ( | :(range '0'-'255') | lower_digit_dash* lower_digit ':' (port_digit | escaped_port_char)+ ) ']' ) "}),e.add({id:25,href:"/docs/examples/ip-addresses/",title:"Example: IP addresses",description:"Test if a string is a valid IPv4 or IPv6 address",content:"Here\u0026rsquo;s a regular expression that checks if a string is a valid IPv4 or IPv6 address:\n^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:(:[0-9a-fA-F]{1,4}){1,6}|:(:[0-9a-fA-F]{1,4}){1,7}|::|fe80:(:[0-9a-fA-F]{1,4}){0,4}%[0-9a-zA-Z]+|::(ffff(:0{1,4})?:)?((25[0-5]|(2[0-4]|1?[0-9])?[0-9])\\.){3}(25[0-5]|(2[0-4]|1?[0-9])?[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1?[0-9])?[0-9])\\.){3}(25[0-5]|(2[0-4]|1?[0-9])?[0-9])|((25[0-5]|(2[0-4]|1?[0-9])?[0-9])\\.){3}(25[0-5]|(2[0-4]|1?[0-9])?[0-9]))$ Here\u0026rsquo;s the same regexp in free-spacing mode with some comments added:\n(?x) ^( ( [0-9a-fA-F]{1,4} : ){7} [0-9a-fA-F]{1,4} | ( [0-9a-fA-F]{1,4} : ){1,7} : | ( [0-9a-fA-F]{1,4} : ){1,6} : [0-9a-fA-F]{1,4} | ( [0-9a-fA-F]{1,4} : ){1,5} ( : [0-9a-fA-F]{1,4} ){1,2} | ( [0-9a-fA-F]{1,4} : ){1,4} ( : [0-9a-fA-F]{1,4} ){1,3} | ( [0-9a-fA-F]{1,4} : ){1,3} ( : [0-9a-fA-F]{1,4} ){1,4} | ( [0-9a-fA-F]{1,4} : ){1,2} ( : [0-9a-fA-F]{1,4} ){1,5} | [0-9a-fA-F]{1,4} : ( : [0-9a-fA-F]{1,4} ){1,6} | : ( : [0-9a-fA-F]{1,4} ){1,7} | :: | fe80: ( : [0-9a-fA-F]{1,4} ){0,4} % [0-9a-zA-Z]+ # link-local IPv6 addresses with zone index | :: ( ffff ( : 0{1,4} )? : )? ( ( 25[0-5] | ( 2[0-4] | 1?[0-9] )? [0-9] ) \\.){3} ( 25[0-5] | ( 2[0-4] | 1?[0-9] )? [0-9] ) # IPv4-mapped IPv6 addresses and IPv4-translated addresses | ( [0-9a-fA-F]{1,4} : ){1,4} : ( ( 25[0-5] | ( 2[0-4] | 1?[0-9] )? [0-9] ) \\.){3} ( 25[0-5] | ( 2[0-4] | 1?[0-9] )? [0-9] ) # IPv4-Embedded IPv6 Address | ( ( 25[0-5] | ( 2[0-4] | 1?[0-9] )? [0-9] ) \\.){3} ( 25[0-5] | ( 2[0-4] | 1?[0-9] )? [0-9] ) # IPv4 )$ And the equivalent pomsky expression:\n# segment in an IPv4 address let num_v4 = range '0'-'255'; # segment in an IPv6 address let num_v6 = [ascii_xdigit]{1,4}; # IPv4 address let ipv4 = (num_v4 '.'){3} num_v4; # link-local IPv6 address with zone index # e.g. fe80::7:8%eth0 fe80::7:8%1 let link_local = 'fe80:' (':' num_v6){0,4} '%' [ascii_alnum]+; # IPv4-Embedded IPv6 Address # e.g. 2001:db8:3:4::192.0.2.33 64:ff9b::192.0.2.33 let ipv4_embedded = (num_v6 ':'){1,4} ':' ipv4; # IPv4-mapped IPv6 address or IPv4-translated address # e.g. ::255.255.255.255 ::ffff:255.255.255.255 ::ffff:0:255.255.255.255 let ipv4_mapped_translated = '::' ('ffff' (':' '0'{1,4})? ':')? ipv4; # IPv6 address let ipv6 = ( | (num_v6 ':'){7} num_v6 | (num_v6 ':'){1,7} ':' | (num_v6 ':'){1,6} (':' num_v6) | (num_v6 ':'){1,5} (':' num_v6){1,2} | (num_v6 ':'){1,4} (':' num_v6){1,3} | (num_v6 ':'){1,3} (':' num_v6){1,4} | (num_v6 ':'){1,2} (':' num_v6){1,5} | (num_v6 ':') (':' num_v6){1,6} | ':' (':' num_v6){1,7} | '::' | link_local | ipv4_mapped_translated | ipv4_embedded ); # IP address ^ (ipv6 | ipv4) $ "}),e.add({id:26,href:"/docs/examples/semver/",title:"Example: Semantic version",description:"Validate a version matches the semver 2.0 spec",content:`Here\u0026rsquo;s a regular expression for parsing a version according to the semver 2.0.0 specification:
(?P\u0026lt;major\u0026gt;\\d+)\\.(?P\u0026lt;minor\u0026gt;\\d+)\\.(?P\u0026lt;patch\u0026gt;\\d+)(?:-(?P\u0026lt;prerelease\u0026gt;[0-9a-zA-Z\\-]+(?:\\.[0-9a-zA-Z\\-]+)*))?(?:\\+(?P\u0026lt;buildmeta\u0026gt;[0-9a-zA-Z\\-]+(?:\\.[0-9a-zA-Z\\-]+)*))? And in free-spacing mode:
(?P\u0026lt;major\u0026gt; \\d+) \\. (?P\u0026lt;minor\u0026gt; \\d+) \\. (?P\u0026lt;patch\u0026gt; \\d+) (?: - (?P\u0026lt;prerelease\u0026gt; [0-9a-zA-Z\\-]+ (?: \\. [0-9a-zA-Z\\-]+ )* ) )? (?: \\+ (?P\u0026lt;buildmeta\u0026gt; [0-9a-zA-Z\\-]+ (?: \\. [0-9a-zA-Z\\-]+ )* ) )? Here\u0026rsquo;s an equivalent pomsky expression:
let number = [digit]+; let identifier = [ascii_alnum '-']+; let identifiers = identifier ('.' identifier)*; :major(number) '.' :minor(number) '.' :patch(number) ('-' :prerelease(identifiers))? ('+' :buildmeta(identifiers))? `}),e.add({id:27,href:"/docs/get-started/",title:"Get Started",description:"Find out what Pomsky is.",content:""}),e.add({id:28,href:"/docs/language-tour/",title:"Language Tour",description:"Learn how to use pomsky.",content:""}),e.add({id:29,href:"/docs/reference/",title:"Reference",description:"Detailed technical info",content:""}),e.add({id:30,href:"/docs/examples/",title:"Examples",description:"Get inspiration from real-world examples",content:""}),e.add({id:31,href:"/docs/",title:"Docs",description:"Pomsky documentation.",content:""}),search.addEventListener("input",t,!0);function t(){const s=5;var n=this.value,o=e.search(n,{limit:s,enrich:!0});const t=new Map;for(const e of o.flatMap(e=>e.result)){if(t.has(e.doc.href))continue;t.set(e.doc.href,e.doc)}if(suggestions.innerHTML="",suggestions.classList.remove("d-none"),t.size===0&&n){const e=document.createElement("div");e.innerHTML=`No results for "<strong>${n}</strong>"`,e.classList.add("suggestion__no-results"),suggestions.appendChild(e);return}for(const[r,a]of t){const n=document.createElement("div");suggestions.appendChild(n);const e=document.createElement("a");e.href=r,n.appendChild(e);const o=document.createElement("span");o.textContent=a.title,o.classList.add("suggestion__title"),e.appendChild(o);const i=document.createElement("span");if(i.textContent=a.description,i.classList.add("suggestion__description"),e.appendChild(i),suggestions.appendChild(n),suggestions.childElementCount==s)break}}})()